<script type="text/worker">

    /**
     * VALOR CHARACTER SHEET
     *
     * Usage:
     * - If you want to use unlisted mods or limits, enter "Custom #", where # is
     * the number of tech levels to add or how much to reduce ST by.
     * - If you want to use unlisted skills or flaws, choose 'Custom Skill' or
     * 'Custom Flaw' and set the level to the amount of SP.
     *
     **/

    let flawLibrary = [
        { cost: 1, levelUp: 1, speed: 3, id: 'customFlaw', namePattern: '^custom' },
        { cost: 2, levelUp: 0, speed: 0, id: 'aggravatedWounds', namePattern: '^aggravated' },
        { cost: 5, levelUp: 0, speed: 0, id: 'berserker', namePattern: '^berserk' },
        { cost: 4, levelUp: 0, speed: 0, id: 'compulsion', namePattern: '^compulsion' },
        { cost: 4, levelUp: 0, speed: 0, id: 'despair', namePattern: '^despair' },
        { cost: 2, levelUp: 1, speed: 2, id: 'energyVulnerability', namePattern: '^energy vuln' },
        { cost: 3, levelUp: 0, speed: 0, id: 'feeble', namePattern: '^feeble' },
        { cost: 3, levelUp: 2, speed: 2, id: 'fragile', namePattern: '^fragile' },
        { cost: 2, levelUp: 1, speed: 2, id: 'lackOfControl', namePattern: '^lack ' },
        { cost: 5, levelUp: 0, speed: 0, id: 'malevolentEntity', namePattern: '^malevolent entity' },
        { cost: 1, levelUp: 0, speed: 0, id: 'nonProficient', namePattern: '^non[ -]?proficient' },
        { cost: 3, levelUp: 0, speed: 0, id: 'oblivious', namePattern: '^oblivious' },
        { cost: 2, levelUp: 1, speed: 1, id: 'slow', namePattern: '^slow$' },
        { cost: 2, levelUp: 0, speed: 0, id: 'slowHealing', namePattern: '^slow heal' },
        { cost: 1, levelUp: 0, speed: 0, id: 'slowToAct', namePattern: '^slow to act' },
        { cost: 3, levelUp: 0, speed: 0, id: 'unthreatening', namePattern: '^unthreatening' },
        { cost: 3, levelUp: 0, speed: 0, id: 'uncoordinated', namePattern: '^uncoordinated' },
        { cost: 3, levelUp: 0, speed: 0, id: 'violent', namePattern: '^violent' },
        { cost: 3, levelUp: 0, speed: 0, id: 'weakAura', namePattern: '^weak aura' },
        { cost: 2, levelUp: 1, speed: 2, id: 'weakDefender', namePattern: '^weak defend' },
        { cost: 4, levelUp: 3, speed: 1, id: 'weakWilled', namePattern: '^weak will' },
        { cost: 1, levelUp: 0, speed: 0, id: 'unprincipled', namePattern: '^unprincipled' },
        { cost: 2, levelUp: 1, speed: 1, id: 'elementalVulnerability', namePattern: '^elemental vuln' },
        { cost: 2, levelUp: 1, speed: 1, id: 'armorReliant', namePattern: '^armor reliant' },
        { cost: 2, levelUp: 1, speed: 1, id: 'wardReliant', namePattern: '^ward reliant' },
        { cost: 3, levelUp: 2, speed: 0, id: 'weakPhysicalAttacker', namePattern: '^weak phys(ical)? attack' },
        { cost: 3, levelUp: 2, speed: 0, id: 'weakEnergyAttacker', namePattern: '^weak en(ergy)? attack' },
        { cost: 4, levelUp: 0, speed: 0, id: 'impairedAccuracy', namePattern: '^impaired acc' },
        { cost: 4, levelUp: 0, speed: 0, id: 'impairedEvasion', namePattern: '^impaired (evd|eva)' },
        { cost: 3, levelUp: 0, speed: 0, id: 'flightless', namePattern: '^malevolent possess' }
    ];
    let skillLibrary = [
        { cost: 1, levelUp: 1, speed: 3, id: 'customSkill', namePattern: '^custom' },
        { cost: 8, levelUp: 0, speed: 0, id: 'balancedFighter', namePattern: '^balanced' },
        { cost: 6, levelUp: 6, speed: 0, id: 'bravado', namePattern: '^bravado' },
        { cost: 3, levelUp: 0, speed: 0, id: 'discreetAura', namePattern: '^discreet' },
        { cost: 4, levelUp: 0, speed: 0, id: 'darksight', namePattern: '^dark( )?sight' },
        { cost: 6, levelUp: 3, speed: 1, id: 'energyAttacker', namePattern: '^en(ergy)? attack' },
        { cost: 4, levelUp: 0, speed: 0, id: 'fastHealing', namePattern: '^fast heal' },
        { cost: 4, levelUp: 2, speed: 1, id: 'improvedDamageIncrement', namePattern: '^improved damage inc' }, // ERRATA: Reduced cost for IDI
        { cost: 2, levelUp: 1, speed: 2, id: 'increasedSize', namePattern: '^increased size' },
        { cost: 4, levelUp: 2, speed: 1, id: 'ironDefense', namePattern: '^iron def' },
        { cost: 6, levelUp: 3, speed: 1, id: 'physicalAttacker', namePattern: '^phys(ical)? attack' },
        { cost: 4, levelUp: 2, speed: 1, id: 'resistant', namePattern: '^resistan' },
        { cost: 4, levelUp: 2, speed: 1, id: 'sprinter', namePattern: '^sprint' },
        { cost: 5, levelUp: 2, speed: 2, id: 'tireless', namePattern: '^tireless' },
        { cost: 6, levelUp: 3, speed: 2, id: 'tough', namePattern: '^tough$' },
        { cost: 6, levelUp: 3, speed: 2, id: 'versatileFighter', namePattern: '^versatile' },
        { cost: 5, levelUp: 0, speed: 0, id: 'skyAttack', namePattern: '^sky attack' },
        { cost: 6, levelUp: 0, speed: 0, id: 'breakValorLimit', namePattern: '^break valor' },
        { cost: 8, levelUp: 0, speed: 0, id: 'expandedReach', namePattern: '^expanded reach' },
        { cost: 12, levelUp: 0, speed: 0, id: 'extraAction', namePattern: '^extra action' },
        { cost: 6, levelUp: 4, speed: 1, id: 'regeneration', namePattern: '^regen' },
        { cost: 4, levelUp: 2, speed: 1, id: 'staminaRecovery', namePattern: '^stamina recover' },
        { cost: 6, levelUp: 0, speed: 0, id: 'teleportation', namePattern: '^teleport' },
        { cost: 6, levelUp: 0, speed: 0, id: 'unyieldingDetermination', namePattern: '^unyielding' }, // ERRATA: Reduced cost, different effect
        { cost: 4, levelUp: 0, speed: 0, id: 'violentAura', namePattern: '^violent aura' },
        { cost: 5, levelUp: 0, speed: 0, id: 'bounceBack', namePattern: '^bounce back' },
        { cost: 4, levelUp: 2, speed: 2, id: 'crisis', namePattern: '^crisis$' },
        { cost: 3, levelUp: 0, speed: 0, id: 'dangerSense', namePattern: '^danger sense' },
        { cost: 5, levelUp: 0, speed: 0, id: 'desperation', namePattern: '^desperation' },
        { cost: 5, levelUp: 0, speed: 0, id: 'digDeep', namePattern: '^dig deep' },
        { cost: 2, levelUp: 0, speed: 0, id: 'discretion', namePattern: '^discretion' },
        { cost: 6, levelUp: 3, speed: 2, id: 'empowerAttack', namePattern: '^empower' },
        { cost: 4, levelUp: 0, speed: 0, id: 'improvedSwimming', namePattern: '^improved swim' },
        { cost: 4, levelUp: 0, speed: 0, id: 'nimbleMovement', namePattern: '^nimble move' },
        { cost: 6, levelUp: 0, speed: 0, id: 'overloadLimits', namePattern: '^overload limit' },
        { cost: 4, levelUp: 0, speed: 0, id: 'passiveHealing', namePattern: '^passive heal' },
        { cost: 5, levelUp: 0, speed: 0, id: 'protector', namePattern: '^protector' },
        { cost: 3, levelUp: 0, speed: 0, id: 'quickToAct', namePattern: '^quick to act' },
        { cost: 5, levelUp: 3, speed: 1, id: 'recklessAttack', namePattern: '^reckless' },
        { cost: 5, levelUp: 0, speed: 0, id: 'resoluteStrike', namePattern: '^resolute strike' },
        { cost: 5, levelUp: 0, speed: 0, id: 'revenge', namePattern: '^revenge' },
        { cost: 4, levelUp: 0, speed: 0, id: 'rollingRecovery', namePattern: '^rolling recover' },
        { cost: 5, levelUp: 0, speed: 0, id: 'teamTactics', namePattern: '^team tactic' },
        { cost: 4, levelUp: 2, speed: 1, id: 'unmovable', namePattern: '^unmovable' },
        { cost: 5, levelUp: 0, speed: 0, id: 'abundantCreation', namePattern: '^abundant creat' },
        { cost: 5, levelUp: 0, speed: 0, id: 'cloneTactics', namePattern: '^clone tactic' },
        { cost: 4, levelUp: 0, speed: 0, id: 'combatToss', namePattern: '^combat toss' },
        { cost: 4, levelUp: 0, speed: 0, id: 'daredevil', namePattern: '^daredevil' },
        { cost: 5, levelUp: 0, speed: 0, id: 'phasing', namePattern: '^phasing' },
        { cost: 6, levelUp: 0, speed: 0, id: 'risingAttack', namePattern: '^rising attack' },
        { cost: 5, levelUp: 0, speed: 0, id: 'safeStride', namePattern: '^safe stride' },
        { cost: 6, levelUp: 0, speed: 0, id: 'splitMove', namePattern: '^split move' },
        { cost: 4, levelUp: 0, speed: 0, id: 'transposition', namePattern: '^transposition' },
        { cost: 5, levelUp: 0, speed: 0, id: 'underhanded', namePattern: '^underhanded' },
        { cost: 4, levelUp: 0, speed: 0, id: 'wallWalk', namePattern: '^wall walk' },
        { cost: 6, levelUp: 0, speed: 0, id: 'waterAdaptation', namePattern: '^water adaptation' },
        { cost: 4, levelUp: 0, speed: 0, id: 'waterWalk', namePattern: '^water walk' },
        { cost: 4, levelUp: 0, speed: 0, id: 'xRayVision', namePattern: '^x[ -]?ray' },
        { cost: 6, levelUp: 0, speed: 0, id: 'unshakeable', namePattern: '^unshakeable' },
        { cost: 6, levelUp: 0, speed: 0, id: 'unstoppable', namePattern: '^unstoppable' },
        { cost: 4, levelUp: 0, speed: 0, id: 'extendedRange', namePattern: '^extended range' },
        { cost: 3, levelUp: 0, speed: 0, id: 'freeFlight', namePattern: '^free flight' },
        { cost: 5, levelUp: 0, speed: 0, id: 'freeSwiftStep', namePattern: '^free swift step' },
        { cost: 5, levelUp: 2, speed: 2, id: 'attackNode', namePattern: '^attack node$' },
        { cost: 5, levelUp: 0, speed: 0, id: 'darkHealing', namePattern: '^dark heal' },
        { cost: 5, levelUp: 0, speed: 0, id: 'dirtyTrick', namePattern: '^dirty trick' },
        { cost: 2, levelUp: 0, speed: 0, id: 'duel', namePattern: '^duel' },
        { cost: 4, levelUp: 3, speed: 1, id: 'effectTransfer', namePattern: '^effect transfer' },
        { cost: 6, levelUp: 0, speed: 0, id: 'feint', namePattern: '^feint' },
        { cost: 5, levelUp: 0, speed: 0, id: 'inspire', namePattern: '^inspire' }, // ERRATA: Fixed level on Inspire
        { cost: 5, levelUp: 3, speed: 1, id: 'intimidate', namePattern: '^intimidate' },
        { cost: 4, levelUp: 0, speed: 0, id: 'jump', namePattern: '^jump' },
        { cost: 5, levelUp: 2, speed: 1, id: 'nullify', namePattern: '^nullify' },
        { cost: 4, levelUp: 2, speed: 2, id: 'provoke', namePattern: '^provoke' },
        { cost: 5, levelUp: 3, speed: 1, id: 'recharge', namePattern: '^recharge' },
        { cost: 3, levelUp: 1, speed: 2, id: 'sizeUp', namePattern: '^size up' },
        { cost: 5, levelUp: 0, speed: 0, id: 'spiritSight', namePattern: '^spirit sight' },
        { cost: 5, levelUp: 2, speed: 1, id: 'toss', namePattern: '^toss' },
        { cost: 6, levelUp: 0, speed: 0, id: 'battleAnalysis', namePattern: '^battle analysis' },
        { cost: 6, levelUp: 0, speed: 1, id: 'clone', namePattern: '^clone$' },
        { cost: 4, levelUp: 0, speed: 0, id: 'effectCapture', namePattern: '^effect capture' },
        { cost: 4, levelUp: 0, speed: 0, id: 'healthTransference', namePattern: '^health transfer' },
        { cost: 6, levelUp: 3, speed: 2, id: 'portal', namePattern: '^portal$' },
        { cost: 4, levelUp: 2, speed: 2, id: 'refractionPoint', namePattern: '^refraction point' },
        { cost: 6, levelUp: 3, speed: 1, id: 'seal', namePattern: '^seal$' },
        { cost: 6, levelUp: 0, speed: 0, id: 'shadowMeld', namePattern: '^shadow( )?meld' },
        { cost: 4, levelUp: 0, speed: 0, id: 'staminaTransference', namePattern: '^stamina transfer' },
        { cost: 5, levelUp: 2, speed: 1, id: 'swiftStep', namePattern: '^swift step' },
        { cost: 4, levelUp: 0, speed: 0, id: 'attackNodeNetwork', namePattern: '^attack node network' },
        { cost: 6, levelUp: 0, speed: 0, id: 'exploitWeakness', namePattern: '^exploit weakness' },
        { cost: 5, levelUp: 0, speed: 0, id: 'flunkyDomination', namePattern: '^flunky domination' },
        { cost: 6, levelUp: 2, speed: 1, id: 'fly', namePattern: '^fly$' },
        { cost: 6, levelUp: 0, speed: 0, id: 'refractionChain', namePattern: '^refraction chain' },
        { cost: 3, levelUp: 0, speed: 0, id: 'swiftJump', namePattern: '^swift jump' },
        { cost: 6, levelUp: 0, speed: 0, id: 'combinationAttack', namePattern: '^comb(o|ination) attack' },
        { cost: 6, levelUp: 0, speed: 0, id: 'counterattack', namePattern: '^counter( )?attack' },
        { cost: 6, levelUp: 2, speed: 2, id: 'cover', namePattern: '^cover$' },
        { cost: 5, levelUp: 0, speed: 0, id: 'ignoreEffect', namePattern: '^ignore effect' },
        { cost: 3, levelUp: 2, speed: 1, id: 'interruptAttack', namePattern: '^interrupt attack' },
        { cost: 4, levelUp: 0, speed: 0, id: 'afterimage', namePattern: '^after( )?image' },
        { cost: 4, levelUp: 0, speed: 0, id: 'areaShield', namePattern: '^area shield' },
        { cost: 3, levelUp: 0, speed: 0, id: 'clash', namePattern: '^clash$' },
        { cost: 5, levelUp: 0, speed: 0, id: 'damageFeedback', namePattern: '^damage feedback' },
        { cost: 5, levelUp: 2, speed: 1, id: 'divingEscape', namePattern: '^diving escape' },
        { cost: 6, levelUp: 0, speed: 0, id: 'finalAttack', namePattern: '^final attack' },
        { cost: 5, levelUp: 0, speed: 0, id: 'lineDeflect', namePattern: '^line deflect' },
        { cost: 5, levelUp: 0, speed: 0, id: 'mobileCover', namePattern: '^mobile cover' },
        { cost: 4, levelUp: 0, speed: 0, id: 'mobileDodge', namePattern: '^mobile dodge' },
        { cost: 6, levelUp: 0, speed: 0, id: 'opportunisticDodge', namePattern: '^opportunistic dodge' },
        { cost: 4, levelUp: 2, speed: 1, id: 'pushAway', namePattern: '^push away' },
        { cost: 4, levelUp: 0, speed: 0, id: 'rangedInterrupt', namePattern: '^ranged interrupt' },
        { cost: 6, levelUp: 0, speed: 0, id: 'shrugOff', namePattern: '^shrug off' },
        { cost: 4, levelUp: 0, speed: 0, id: 'defensiveClash', namePattern: '^defensive clash' },
        { cost: 4, levelUp: 0, speed: 0, id: 'deflectingShield', namePattern: '^deflecting shield' },
        { cost: 6, levelUp: 0, speed: 0, id: 'prepared', namePattern: '^prepared' },
        { cost: 5, levelUp: 0, speed: 0, id: 'acceleration', namePattern: '^acceleration' },
        { cost: 5, levelUp: 0, speed: 0, id: 'analysis', namePattern: '^analysis' },
        { cost: 6, levelUp: 3, speed: 1, id: 'blazingMight', namePattern: '^blazing might' },
        { cost: 5, levelUp: 0, speed: 0, id: 'burningPassion', namePattern: '^burning passion' },
        { cost: 6, levelUp: 3, speed: 1, id: 'fightingSpirit', namePattern: '^fighting spirit' },
        { cost: 6, levelUp: 3, speed: 1, id: 'hardenedDefense', namePattern: '^hardened def' },
        { cost: 6, levelUp: 3, speed: 1, id: 'hardenedResistance', namePattern: '^hardened res' },
        { cost: 5, levelUp: 0, speed: 0, id: 'resoluteAura', namePattern: '^resolute aura' },
        { cost: 5, levelUp: 0, speed: 0, id: 'strengthOfWill', namePattern: '^strength of will' },
        { cost: 3, levelUp: 0, speed: 0, id: 'asset', namePattern: '^asset' },
        { cost: 3, levelUp: 0, speed: 0, id: 'challengeTechnique', namePattern: '^challenge tech' },
        { cost: 3, levelUp: 0, speed: 0, id: 'favorableInsight', namePattern: '^favo(u)?rable insight' },
        { cost: 2, levelUp: 0, speed: 0, id: 'proficiency', namePattern: '^proficiency' },
        { cost: 3, levelUp: 0, speed: 0, id: 'recovery', namePattern: '^recovery' },
        { cost: 4, levelUp: 0, speed: 0, id: 'favorableSuccess', namePattern: '^favorable success' },
        { cost: 6, levelUp: 4, speed: 1, id: 'companion', namePattern: '^companion$' },
        { cost: 2, levelUp: 1, speed: 2, id: 'fastCompanion', namePattern: '^fast companion' },
        { cost: 4, levelUp: 2, speed: 1, id: 'hiddenCompanion', namePattern: '^hidden companion' },
        { cost: 3, levelUp: 1, speed: 1, id: 'mount', namePattern: '^mount$' },
        { cost: 2, levelUp: 0, speed: 0, id: 'senseMalice', namePattern: '^sense malice' },
        { cost: 3, levelUp: 1, speed: 1, id: 'allyMount', namePattern: '^ally mount' },
        { cost: 4, levelUp: 4, speed: 1, id: 'companionZoneOfControl', namePattern: '^companion z' },
        { cost: 4, levelUp: 0, speed: 0, id: 'extendedRevival', namePattern: '^extended reviv' },
        { cost: 4, levelUp: 0, speed: 0, id: 'flankAttack', namePattern: '^flank' },
        { cost: 2, levelUp: 0, speed: 0, id: 'protectAlly', namePattern: '^protect ally' },
        { cost: 4, levelUp: 0, speed: 0, id: 'protectMaster', namePattern: '^protect master' },
        { cost: 3, levelUp: 0, speed: 0, id: 'rangedRevival', namePattern: '^ranged reviv' },
        { cost: 3, levelUp: 1, speed: 1, id: 'tossingCompanion', namePattern: '^tossing companion' },
        { cost: 4, levelUp: 0, speed: 0, id: 'trustingCompanion', namePattern: '^trusting companion' },
        { cost: 2, levelUp: 0, speed: 0, id: 'companionSense', namePattern: '^companion sense' },
        { cost: 3, levelUp: 3, speed: 1, id: 'flyingCompanion', namePattern: '^flying companion' },
        { cost: 3, levelUp: 0, speed: 0, id: 'instantMount', namePattern: '^instant mount' },
        { cost: 4, levelUp: 0, speed: 0, id: 'reactiveCompanion', namePattern: '^reactive companion' },
        { cost: 12, levelUp: 0, speed: 0, id: 'limitlessPower', namePattern: '^valiant' },
        { cost: 8, levelUp: 0, speed: 0, id: 'invisibility', namePattern: '^invisibility' },
        { cost: 8, levelUp: 3, speed: 1, id: 'revive', namePattern: '^revive$' },
        { cost: 2, levelUp: 0, speed: 0, id: 'principled', namePattern: '^principled' },
        { cost: 6, levelUp: 3, speed: 2, id: 'illusoryAssailant', namePattern: '^illusory assailant' },
        { cost: 3, levelUp: 0, speed: 0, id: 'illusoryDisguise', namePattern: '^illusory disguise' },
        { cost: 4, levelUp: 2, speed: 2, id: 'illusoryTerrain', namePattern: '^illusory terrain' },
        { cost: 4, levelUp: 0, speed: 0, id: 'pierceIllusion', namePattern: '^pierce illusion' },
        { cost: 4, levelUp: 2, speed: 1, id: 'elementalResistance', namePattern: '^elemental resist' },
        { cost: 3, levelUp: 0, speed: 0, id: 'elementalAttunement', namePattern: '^elemental attune' },
        { cost: 2, levelUp: 0, speed: 0, id: 'changeAttributes', namePattern: '^change attr' },
        { cost: 2, levelUp: 2, speed: 0, id: 'enhancedRange', namePattern: '^enhanced range' },
        { cost: 8, levelUp: 0, speed: 0, id: 'greatAccuracy', namePattern: '^great acc' },
        { cost: 8, levelUp: 0, speed: 0, id: 'greatEvasion', namePattern: '^great (evd|eva)' },
        { cost: 6, levelUp: 0, speed: 0, id: 'powerfulBlow', namePattern: '^powerful blow' }
    ];
    let coreLibrary = [
        { cost: 2, levelUp: 1, id: 'damage' },
        { cost: 1, levelUp: 1, id: 'barrier' },
        { cost: 0, levelUp: 2, id: 'boost' },
        { cost: 1, levelUp: 1, id: 'healing' },
        { cost: 0, levelUp: 0, id: 'mimic' },
        { cost: 3, levelUp: 2, id: 'summoning' },
        { cost: 1, levelUp: 1, id: 'weaken' },
        { cost: 4, levelUp: 2, id: 'ultDamage' },
        { cost: 0, levelUp: 3, id: 'ultTransform' },
        { cost: 0, levelUp: 3, id: 'ultMimic' }
    ];

    function calculateBaseAttributes() {
        log('VALOR - Recalculating Base Attributes');
        getAttrs(['level', 'strength', 'agility', 'spirit', 'mind', 'guts'], function(values) {
            let level = parseInt(values.level);
            let strength = parseInt(values.strength);
            let agility = parseInt(values.agility);
            let spirit = parseInt(values.spirit);
            let mind = parseInt(values.mind);
            let guts = parseInt(values.guts);

            if(strength > level + 7) {
                strength = level + 7;
            }
            if(agility > level + 7) {
                agility = level + 7;
            }
            if(spirit > level + 7) {
                spirit = level + 7;
            }
            if(mind > level + 7) {
                mind = level + 7;
            }
            if(guts > level + 7) {
                guts = level + 7;
            }

            if(strength < 1) {
                strength = 1
            }
            if(agility < 1) {
                agility = 1
            }
            if(spirit < 1) {
                spirit = 1
            }
            if(mind < 1) {
                mind = 1
            }
            if(guts < 1) {
                guts = 1
            }

            let unspentAttributePoints = 22 + 3 * level - strength - agility - spirit - mind - guts;

            // Set values
            setAttrs({
                strength: strength,
                agility: agility,
                spirit: spirit,
                mind: mind,
                guts: guts,
                unspentAttributePoints: unspentAttributePoints
            });
        });
    }

    function calculateActiveAttributes() {
        log('VALOR - Recalculating Active Attributes');
        getAttrs(['level', 'strength', 'agility', 'spirit', 'mind', 'guts', 'type'], function(values) {
            const level = parseInt(values.level);
            const strength = parseInt(values.strength);
            const agility = parseInt(values.agility);
            const spirit = parseInt(values.spirit);
            const mind = parseInt(values.mind);
            const guts = parseInt(values.guts);

            let muscle = Math.ceil((level + strength) / 2);
            let dexterity = Math.ceil((level + agility) / 2);
            let aura = Math.ceil((level + spirit) / 2);
            let intuition = Math.ceil((level + mind) / 2);
            let resolve = Math.ceil((level + guts) / 2);

            switch(values.type) {
                case 'flunky':
                case 'soldier':
                    muscle--;
                    dexterity--;
                    aura--;
                    intuition--;
                    resolve--;
                    break;
            }

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        const skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                        if(skillName && skillName == 'balancedFighter') {
                            let stats = [muscle, dexterity, aura, intuition, resolve];
                            const highestStat = Math.max(...stats);
                            if(muscle < highestStat) {
                                muscle++;
                            }
                            if(dexterity < highestStat) {
                                dexterity++;
                            }
                            if(aura < highestStat) {
                                aura++;
                            }
                            if(intuition < highestStat) {
                                intuition++;
                            }
                            if(resolve < highestStat) {
                                resolve++;
                            }
                        }
                    }

                    // Set values
                    setAttrs({
                        muscle: muscle,
                        dexterity: dexterity,
                        aura: aura,
                        intuition: intuition,
                        resolve: resolve
                    });
                });
            });
        });
    }

    function calculateAttack() {
        log('VALOR - Recalculating Attack');
        getAttrs(['level', 'strength', 'agility', 'spirit', 'mind', 'guts', 'type'], function(values) {
            let level = parseInt(values.level);
            let strength = parseInt(values.strength);
            let agility = parseInt(values.agility);
            let spirit = parseInt(values.spirit);
            let mind = parseInt(values.mind);
            let guts = parseInt(values.guts);

            let strengthAttack = (level + strength) * 2;
            let agilityAttack = (level + agility) * 2;
            let spiritAttack = (level + spirit) * 2;
            let mindAttack = (level + mind) * 2;

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }
                        let skillLevel = 1;
                        if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                            skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                        }

                        switch(skillName) {
                            case 'energyAttacker':
                                spiritAttack += 3 + 3 * skillLevel;
                                mindAttack += 3 + 3 * skillLevel;
                                break;
                            case 'physicalAttacker':
                                strengthAttack += 3 + 3 * skillLevel;
                                agilityAttack += 3 + 3 * skillLevel;
                                break;
                        }
                    }

                    switch(values.type) {
                        case 'flunky':
                        case 'soldier':
                        case 'swarm':
                            strengthAttack = Math.ceil(strengthAttack / 2);
                            agilityAttack = Math.ceil(agilityAttack / 2);
                            spiritAttack = Math.ceil(spiritAttack / 2);
                            mindAttack = Math.ceil(mindAttack / 2);
                            break;
                        case 'master':
                            strengthAttack += strength;
                            agilityAttack += agility;
                            spiritAttack += spirit;
                            mindAttack += mind;
                            break;
                    }

                    // Set values
                    setAttrs({
                        strengthAttack: strengthAttack,
                        agilityAttack: agilityAttack,
                        spiritAttack: spiritAttack,
                        mindAttack: mindAttack
                    });
                });
            });
        });
    }

    function calculateHealth() {
        log('VALOR - Recalculating Max Health');
        getAttrs(['level', 'strength', 'guts', 'type'], function(values) {
            let level = parseInt(values.level);
            let strength = parseInt(values.strength);
            let guts = parseInt(values.guts);

            let health = 50 + 10 * level + 10 * guts + 5 * strength;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawname`);
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawlevel`);
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues[`repeating_flaws_${idarray[i]}_flawname`];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]) {
                            flawLevel = parseInt(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'fragile':
                                health -= 15 + 15 * flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                                    skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                                }

                                switch(skillName) {
                                    case 'tough':
                                        health += 15 + 15 * skillLevel;
                                        break;
                                }
                            }

                            switch(values.type) {
                                case 'flunky':
                                    health = 1;
                                    break;
                                case 'soldier':
                                    health = Math.ceil(health / 2);
                                    break;
                                case 'master':
                                    health *= 2;
                                    break;
                            }

                            // Set values
                            setAttrs({
                                health_max: health,
                                healthIncrement: Math.ceil(health / 5),
                                criticalHealth: Math.ceil(health / 5) * 2
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateStamina() {
        log('VALOR - Recalculating Max Stamina');
        getAttrs(['level', 'mind', 'spirit', 'type'], function(values) {
            let level = parseInt(values.level);
            let mind = parseInt(values.mind);
            let spirit = parseInt(values.spirit);

            let stamina = 8 + 4 * level + 2 * spirit + 2 * mind;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawname`);
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawlevel`);
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues[`repeating_flaws_${idarray[i]}_flawname`];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]) {
                            flawLevel = parseInt(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'lackOfControl':
                                stamina -= 2 + 6 * flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                                    skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                                }

                                switch(skillName) {
                                    case 'tireless':
                                        stamina += 2 + 6 * skillLevel;
                                        break;
                                }
                            }

                            switch(values.type) {
                                case 'master':
                                    stamina *= 2;
                                    break;
                            }

                            // Set values
                            setAttrs({
                                stamina_max: stamina,
                                staminaIncrement: Math.ceil(stamina / 5)
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateDefense() {
        log('VALOR - Recalculating Defense');
        getAttrs(['level', 'strength', 'guts', 'type'], function(values) {
            let level = parseInt(values.level);
            let strength = parseInt(values.strength);
            let guts = parseInt(values.guts);

            let defense = 2 * level + strength + guts;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawname`);
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawlevel`);
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues[`repeating_flaws_${idarray[i]}_flawname`];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]) {
                            flawLevel = parseInt(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'weakDefender':
                                defense -= 2 + 2 * flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                                    skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                                }

                                switch(skillName) {
                                    case 'ironDefense':
                                        defense += 2 + 2 * skillLevel;
                                        break;
                                }
                            }

                            // Set values
                            setAttrs({
                                defense: defense
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateResistance() {
        log('VALOR - Recalculating Resistance');
        getAttrs(['level', 'spirit', 'mind', 'type'], function(values) {
            let level = parseInt(values.level);
            let spirit = parseInt(values.spirit);
            let mind = parseInt(values.mind);

            let resistance = 2 * level + spirit + mind;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawname`);
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawlevel`);
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues[`repeating_flaws_${idarray[i]}_flawname`];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]) {
                            flawLevel = parseInt(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'energyVulnerability':
                                resistance -= 2 + 2 * flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                                    skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                                }

                                switch(skillName) {
                                    case 'resistant':
                                        resistance += 2 + 2 * skillLevel;
                                        break;
                                }
                            }

                            // Set values
                            setAttrs({
                                resistance: resistance
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateMove() {
        log('VALOR - Recalculating Move');
        getAttrs(['agility'], function(values) {
            let agility = parseInt(values.agility);

            let move = Math.ceil(agility / 4) + 2;

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawname`);
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawlevel`);
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues[`repeating_flaws_${idarray[i]}_flawname`];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        let flawLevel = 1;
                        if(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]) {
                            flawLevel = parseInt(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]);
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'slow':
                                move -= flawLevel;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                let skillLevel = 1;
                                if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                                    skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                                }

                                switch(skillName) {
                                    case 'sprinter':
                                        move += skillLevel;
                                        break;
                                }
                            }

                            // Set values
                            setAttrs({
                                move: move
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateDamageIncrement() {
        log('VALOR - Recalculating Damage Increment');
        getAttrs(['level', 'type'], function(values) {
            let level = parseInt(values.level);

            let damageIncrement = level + 5;

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }
                        let skillLevel = 1;
                        if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                            skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                        }

                        switch(skillName) {
                            case 'improvedDamageIncrement':
                                damageIncrement += 2 + 2 * skillLevel; // ERRATA: More powerful IDI
                                break;
                        }
                    }

                    switch(values.type) {
                        case 'flunky':
                        case 'soldier':
                            damageIncrement = Math.ceil(damageIncrement / 2);
                            break;
                    }

                    // Set values
                    setAttrs({
                        damageIncrement: damageIncrement
                    });
                });
            });
        });
    }

    function calculateInitiative() {
        log('VALOR - Recalculating Initiative');
        getAttrs(['dexterity'], function(values) {
            let initiative = parseInt(values.dexterity);

            // Apply Flaws
            let flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(let i = 0; i < idarray.length; i++) {
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawname`);
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawlevel`);
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    for(let i = 0; i < idarray.length; i++) {
                        let flawName = flawValues[`repeating_flaws_${idarray[i]}_flawname`];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }

                        // Apply effects
                        switch(flawName) {
                            case 'slowToAct':
                                initiative -= 2;
                                break;
                        }
                    }

                    // Apply Skills
                    let skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(let i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(let i = 0; i < sidarray.length; i++) {
                                let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }

                                switch(skillName) {
                                    case 'quickToAct':
                                        initiative += 2;
                                        break;
                                }
                            }

                            // Set values
                            setAttrs({
                                initiative: initiative
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateBonuses() {
        log('VALOR - Recalculating Attack/Defense Bonuses');
        getAttrs(['type'], function(values) {

            let atkBonus = 0;
            let defBonus = 0;

            if(values.type == 'master') {
                atkBonus++;
            }

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }
                        let skillLevel = 1;
                        if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                            skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                        }

                        switch(skillName) {
                            case 'increasedSize':
                                atkBonus++;
                                defBonus--;
                                break;
                            case 'diminuitive':
                                atkBonus--;
                                defBonus++;
                                break;
                        }
                    }

                    let atkBonusDisp = ' ';
                    if(atkBonus > 0) atkBonusDisp = `+${atkBonus}`;
                    if(atkBonus < 0) atkBonusDisp = atkBonus;
                    let defBonusDisp = ' ';
                    if(defBonus > 0) defBonusDisp = `+${defBonus}`;
                    if(defBonus < 0) defBonusDisp = defBonus;

                    // Set values
                    setAttrs({
                        iatkrollbonus: atkBonus,
                        idefrollbonus: defBonus,
                        iatkrollbonusdisp: atkBonusDisp,
                        idefrollbonusdisp: defBonusDisp,
                    });
                });
            });
        });
    }

    // Utility function that unpacks camelcase into a display name.
    function getDisplayName(name) {
        return name
            .replace(/([A-Z])/g, ' $1')
            .replace(/^./, function(str) { return str.toUpperCase(); });
    }

    function calculateFlawsAndSkills() {
        log('VALOR - Recalculating Flaws & Skills');
        getAttrs(['level', 'type'], function(values) {
            var level = parseInt(values.level);
            var unspentSkillPoints = 14 + 6 * level;

            // Various values determined solely by skill list
            var valor = 10;
            var hasUlt = false;

            switch(values.type) {
                case 'flunky':
                case 'soldier':
                    unspentSkillPoints = Math.ceil(unspentSkillPoints / 2);
                    break;
                case 'master':
                    unspentSkillPoints += 4 + level;
                    break;
            }

            // Apply Flaws
            var flawFieldNames = [];
            getSectionIDs('repeating_flaws', function(idarray) {
                for(var i = 0; i < idarray.length; i++) {
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawname`);
                    flawFieldNames.push(`repeating_flaws_${idarray[i]}_flawlevel`);
                }
                getAttrs(flawFieldNames, function(flawValues) {
                    var flawSP = 0;
                    for(var i = 0; i < idarray.length; i++) {
                        var warning = ' ';
                        var flawName = flawValues[`repeating_flaws_${idarray[i]}_flawname`];
                        if(!flawName) {
                            flawName = 'customFlaw';
                        }
                        var flawLevel = 1;
                        if(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]) {
                            flawLevel = parseInt(flawValues[`repeating_flaws_${idarray[i]}_flawlevel`]);
                        }

                        var flaw = flawLibrary.find(function(f) {
                            return f.id == flawName;
                        });

                        if(flaw) {
                            var flawMaxLevel = 1;
                            switch(flaw.speed) {
                                case 1:
                                    flawMaxLevel = Math.ceil(level / 5);
                                    break;
                                case 2:
                                    flawMaxLevel = Math.ceil(level / 3);
                                    break;
                                case 3:
                                    flawMaxLevel = 100; // Custom Flaw
                            }
                            if(flawLevel > flawMaxLevel && flaw.speed != 3) {
                                warning = `Warning: Level cap for this Flaw is ${flawMaxLevel}.`;
                            }

                            var flawAttrs = {};
                            flawAttrs[`repeating_flaws_${idarray[i]}_warning`] = warning;
                            setAttrs(flawAttrs, { silent: true });

                            flawSP += flaw.cost + (flawLevel - 1) * flaw.levelUp;
                        }
                    }

                    // Gain SP from Flaws
                    if(flawSP > level + 7) {
                        flawSP = level + 7;
                    }
                    unspentSkillPoints += flawSP;

                    // Apply Skills
                    var skillFieldNames = [];
                    getSectionIDs('repeating_skills', function(sidarray) {
                        for(var i = 0; i < sidarray.length; i++) {
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                            skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                        }
                        getAttrs(skillFieldNames, function(skillValues) {
                            for(var i = 0; i < sidarray.length; i++) {
                                var warning = ' ';
                                var skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                                if(!skillName) {
                                    skillName = 'customSkill';
                                }
                                var skillLevel = 1;
                                if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                                    skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                                }

                                switch(skillName) {
                                    case 'breakValorLimit':
                                        valor += 10;
                                        break;
                                }

                                var skill = skillLibrary.find(function(s) {
                                    return s.id == skillName;
                                });

                                if(skill) {
                                    var skillMaxLevel = 1;
                                    switch(skill.speed) {
                                        case 1:
                                            skillMaxLevel = Math.ceil(level / 5);
                                            break;
                                        case 2:
                                            skillMaxLevel = Math.ceil(level / 3);
                                            break;
                                        case 3:
                                            skillMaxLevel = 100; // Custom Skill
                                    }

                                    if(skillLevel > skillMaxLevel && skill.level != 3) {
                                        warning = `Warning: Level cap for this Skill is ${skillMaxLevel}.`;
                                    }

                                    var skillAttrs = {};
                                    skillAttrs[`repeating_skills_${sidarray[i]}_warning`] = warning;
                                    setAttrs(skillAttrs, { silent: true });

                                    unspentSkillPoints -= skill.cost + (skillLevel - 1) * skill.levelUp;
                                }
                            }

                            // Set values
                            setAttrs({
                                unspentSkillPoints: unspentSkillPoints,
                                valor_max: valor
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateTP() {
        log('VALOR - Recalculating Unspent TP');
        getAttrs(['level', 'type'], function(values) {
            let level = parseInt(values.level);

            let unspentTechPoints = 8 + 4 * level;
            let flunkyTP = 2 + level;
            let soldierTP = 4 + 2 * level;
            if(level > 5) {
                unspentTechPoints += level - 5;
                flunkyTP += level - 5;
                soldierTP += level - 5;
            }
            if(level > 10) {
                unspentTechPoints += level - 10;
            }
            if(level > 15) {
                unspentTechPoints += level - 15;
                soldierTP += level - 15;
            }

            let hasUlt = false;

            switch(values.type) {
                case 'flunky':
                    unspentTechPoints = flunkyTP;
                    break;
                case 'soldier':
                case 'swarm':
                    unspentTechPoints = soldierTP;
                    break;
                case 'master':
                    unspentTechPoints += 1 + level;
                    break;

            }

            // Apply Skills
            let skillFieldNames = [];
            getSectionIDs('repeating_skills', function(sidarray) {
                for(let i = 0; i < sidarray.length; i++) {
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skillname`);
                    skillFieldNames.push(`repeating_skills_${sidarray[i]}_skilllevel`);
                }
                getAttrs(skillFieldNames, function(skillValues) {
                    for(let i = 0; i < sidarray.length; i++) {
                        let skillName = skillValues[`repeating_skills_${sidarray[i]}_skillname`];
                        if(!skillName) {
                            skillName = 'customSkill';
                        }
                        let skillLevel = 1;
                        if(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]) {
                            skillLevel = parseInt(skillValues[`repeating_skills_${sidarray[i]}_skilllevel`]);
                        }

                        switch(skillName) {
                            case 'versatileFighter':
                                switch(values.type) {
                                    case 'flunky':
                                        unspentTechPoints += skillLevel;
                                        break;
                                    case 'soldier':
                                    case 'swarm':
                                        unspentTechPoints += 2 + skillLevel;
                                        break;
                                    default:
                                        unspentTechPoints += 2 + 2 * skillLevel;
                                        break;
                                }
                                break;
                            case 'ultimateAttack':
                                hasUlt = true;
                                break;
                        }
                    }

                    // Apply techs
                    let techFieldNames = [];
                    getSectionIDs('repeating_techs', function(tidarray) {
                        for(let i = 0; i < tidarray.length; i++) {
                            techFieldNames.push(`repeating_techs_${tidarray[i]}_tech_core_level`);
                            techFieldNames.push(`repeating_techs_${tidarray[i]}_tech_mod_level`);
                            techFieldNames.push(`repeating_techs_${tidarray[i]}_tech_core`);
                        }

                        getAttrs(techFieldNames, function(techValues) {

                            let ults = [];
                            if(level >= 5) {
                                ults.push(8);
                            }
                            if(level >= 10) {
                                ults.push(13);
                            }
                            if(level >= 15) {
                                ults.push(18);
                            }
                            if(level >= 20) {
                                ults.push(23);
                            }
                            if(hasUlt) {
                                ults.push(level);
                            }

                            for(let i = 0; i < tidarray.length; i++) {
                                techCore = techValues[`repeating_techs_${tidarray[i]}_tech_core`];
                                let techCoreLevel = 1;
                                if(techValues[`repeating_techs_${tidarray[i]}_tech_core_level`]) {
                                    techCoreLevel = parseInt(techValues[`repeating_techs_${tidarray[i]}_tech_core_level`]);
                                }
                                let techModsLevel = 0;
                                if(techValues[`repeating_techs_${tidarray[i]}_tech_mod_level`]) {
                                    techModsLevel = parseInt(techValues[`repeating_techs_${tidarray[i]}_tech_mod_level`]);
                                }

                                let spentTP = techModsLevel + techCoreLevel;

                                // Set the tech's total level
                                let techAttrs = {};
                                techAttrs[`repeating_techs_${tidarray[i]}_tech_level`] = spentTP;
                                setAttrs(techAttrs);

                                if((techCore == 'ultDamage' || techCore == 'ultTransform' || techCore == 'ultMimic' || techCore == 'domain')
                                    && ults.length > 0) {
                                    // Use the next Ult to offset the TP cost
                                    spentTP -= ults[0];
                                    ults.splice(0,1);
                                }

                                if(spentTP > 0) {
                                    unspentTechPoints -= spentTP;
                                }
                            }

                            // Set values
                            setAttrs({
                                unspentTechPoints: unspentTechPoints
                            });
                        });
                    });
                });
            });
        });
    }

    function calculateTech(techId) {
        log(`VALOR - Recalculating Technique ID ${techId}`);

        let techFieldNames = ['strength', 'agility', 'spirit', 'mind', 'guts',
                              'muscle', 'dexterity', 'aura', 'intuition', 'resolve',
                              'strengthAttack', 'agilityAttack', 'spiritAttack', 'mindAttack',
                              'level', 'hp_max', 'damageIncrement', 'type',
                              'rollbonus', 'atkrollbonus', 'iatkrollbonus', 'eatkbonus', 'patkbonus',
                              'hasDigDeep', 'hasOverloadLimits', 'hasEmpowerAttack', 'hasResoluteStrike', 'healerLevel'];

        techFieldNames.push(`repeating_techs_${techId}_tech_name`);
        techFieldNames.push(`repeating_techs_${techId}_tech_core_level`);
        techFieldNames.push(`repeating_techs_${techId}_tech_core`);
        techFieldNames.push(`repeating_techs_${techId}_tech_stat`);
        techFieldNames.push(`repeating_techs_${techId}_tech_mods`);
        techFieldNames.push(`repeating_techs_${techId}_tech_limits`);
        techFieldNames.push(`repeating_techs_${techId}_tech_description`);
        techFieldNames.push(`repeating_techs_${techId}_tech_granted_skills`);
        techFieldNames.push(`repeating_techs_${techId}_tech_inflicted_flaws`);
        techFieldNames.push(`repeating_techs_${techId}_tech_targets`);
        techFieldNames.push(`repeating_techs_${techId}_tech_custom_cost`);

        getAttrs(techFieldNames, function(techValues) {
            const level = parseInt(techValues.level);
            const health = parseInt(techValues.hp_max);
            const damageIncrement = parseInt(techValues.damageIncrement);
            const strength = parseInt(techValues.strength);
            const agility = parseInt(techValues.agility);
            const spirit = parseInt(techValues.spirit);
            const mind = parseInt(techValues.mind);
            const guts = parseInt(techValues.guts);
            const rollBonus = parseInt(techValues.rollbonus);
            const attackRollBonus = parseInt(techValues.atkrollbonus);
            const inherentAttackRollBonus = parseInt(techValues.iatkrollbonus);
            const energyAttackBonus = parseInt(techValues.eatkbonus);
            const physicalAttackBonus = parseInt(techValues.patkbonus);

            let techName = techValues[`repeating_techs_${techId}_tech_name`];
            let techStat = techValues[`repeating_techs_${techId}_tech_stat`];
            let techGrantedSkills = techValues[`repeating_techs_${techId}_tech_granted_skills`];
            let techInflictedFlaws = techValues[`repeating_techs_${techId}_tech_inflicted_flaws`];
            let techDescription = techValues[`repeating_techs_${techId}_tech_description`];
            let techCore = 'damage';
            if(techValues[`repeating_techs_${techId}_tech_core`]) {
                techCore = techValues[`repeating_techs_${techId}_tech_core`];
            }
            let techMods = '';
            if(techValues[`repeating_techs_${techId}_tech_mods`]) {
                techMods = techValues[`repeating_techs_${techId}_tech_mods`].toLowerCase();
            }
            let techLimits = '';
            if(techValues[`repeating_techs_${techId}_tech_limits`]) {
                techLimits = techValues[`repeating_techs_${techId}_tech_limits`].toLowerCase();
            }
            let techCoreLevel = 1;
            if(techValues[`repeating_techs_${techId}_tech_core_level`]) {
                techCoreLevel = parseInt(techValues[`repeating_techs_${techId}_tech_core_level`]);
            }
            let techTargets = 1;
            if(techValues[`repeating_techs_${techId}_tech_targets`]) {
                techTargets = parseInt(techValues[`repeating_techs_${techId}_tech_targets`]);
            }
            if(techTargets > 20) {
                techTargets = 20;
            }
            let techCustomCost = 0;
            if(techValues[`repeating_techs_${techId}_tech_custom_cost`]) {
                techCustomCost = parseInt(techValues[`repeating_techs_${techId}_tech_custom_cost`]);
            }


            // Build tech summary
            let summary = '';
            let warnings = [];

            let hasSkills = false;
            let hasFlaws = false;
            let barrierFreebie = false;
            let isPersistent = false;

            if(techCoreLevel < 1) {
                warnings.push('Core Power cannot be less than 1.');
            }

            // Is this an ult?
            if(techCore == 'ultDamage' || techCore == 'ultTransform' ||
               techCore == 'ultMimic' || techCore == 'domain') {
                summary += 'Ultimate Technique. ';
            }

            // Display required action
            let action = 'Attack';
            if(techCore == 'barrier' || techCore == 'boost' ||
               techCore == 'healing' || techCore == 'weaken' ||
               techCore == 'ultTransform') {
                action  = 'Support';
            }
            if(techMods.indexOf('rush') > -1 || techMods.indexOf('ramming') > -1) {
                action += '+Move';
            }
            if((techCore == 'summoning' && techMods.indexOf('quick summon') == -1) || techLimits.indexOf('slow') > -1) {
                action = 'Slow';
            }
            if(techCore != 'custom') {
                summary += `${action} Action. `;
            }

            // Display core functionality
            let rollStat = techStat;
            if(techMods.indexOf('muscular') > -1) {
                rollStat = 'strength';
            }
            if(techMods.indexOf('dexterous') > -1 ||
               techMods.indexOf('dextrous') > -1) {
                rollStat = 'agility';
            }
            if(techMods.indexOf('aura') > -1) {
                rollStat = 'spirit';
            }
            if(techMods.indexOf('intuitive') > -1) {
                rollStat = 'mind';
            }
            
            let techRoll = '';
            let amount = 0;
            let defRes = 'def';
            let microSummary = '';

            if(techCore == 'damage' ||
               techCore == 'ultDamage' ||
               techCore == 'weaken' ||
               techCore == 'custom') {
                let hitBonus = 0;
                if(techMods.indexOf('accurate') > -1) {
                    hitBonus += 2;
                }
                if(techLimits.indexOf('final') > -1) {
                    hitBonus += 5;
                }
                let toHit = 0;
                switch(rollStat) {
                    case 'strength':
                        toHit = techValues.muscle + hitBonus;
                        summary += `Roll Muscle (1d10+${toHit}) to hit. `;
                        break;
                    case 'agility':
                        toHit = techValues.dexterity + hitBonus;
                        summary += `Roll Dexterity (1d10+${toHit}) to hit. `;
                        break;
                    case 'spirit':
                        toHit = techValues.aura + hitBonus;
                        summary += `Roll Aura (1d10+${toHit}) to hit. `;
                        break;
                    case 'mind':
                        toHit = techValues.intuition + hitBonus;
                        summary += `Roll Intuition (1d10+${toHit}) to hit. `;
                        break;
                    case 'guts':
                        toHit = techValues.resolve + hitBonus;
                        summary += `Roll Resolve (1d10+${toHit}) to hit. `;
                        break;
                }
                
                if(techCore == 'damage' || techCore == 'ultDamage') {
                    toHit += attackRollBonus + inherentAttackRollBonus;
                }
                toHit += rollBonus;
                
                techRoll += `[[1d10+${toHit}]] `;
                if(techStat == 'strength') techRoll += 'Muscle';
                if(techStat == 'agility') techRoll += 'Dexterity';
                if(techStat == 'mind') techRoll += 'Intuition';
                if(techStat == 'spirit') techRoll += 'Aura';
                if(techStat == 'guts') techRoll += 'Resolve';
            }
            
            switch(techCore) {
                case 'damage':
                case 'ultDamage':

                    // Get damage and stat for description
                    let specialAttack =
                        techMods.indexOf('sapping') > -1 ||
                        techMods.indexOf('piercing') > -1 ||
                        techMods.indexOf('drain') > -1 ||
                        techMods.indexOf('persistent') > -1 ||
                        techMods.indexOf('debilitating') > -1 ||
                        techMods.indexOf('boosting') > -1;
                    switch(techStat) {
                        case 'strength':
                            if(specialAttack && techCore == 'damage') {
                                amount = 12 + 4 * techCoreLevel + Math.ceil(techValues.strengthAttack / 2);
                            } else if((!specialAttack && techCore == 'damage') || (specialAttack && techCore == 'ultDamage')) {
                                amount = 15 + 5 * techCoreLevel + techValues.strengthAttack;
                            } else {
                                amount = 24 + 8 * techCoreLevel + techValues.strengthAttack;
                            }
                            amount += physicalAttackBonus;
                            summary += `On a hit, deal ${amount} physical damage to the target. `;
                            break;
                        case 'agility':
                            if(specialAttack && techCore == 'damage') {
                                amount = 12 + 4 * techCoreLevel + Math.ceil(techValues.agilityAttack / 2);
                            } else if((!specialAttack && techCore == 'damage') || (specialAttack && techCore == 'ultDamage')) {
                                amount = 15 + 5 * techCoreLevel + techValues.agilityAttack;
                            } else {
                                amount = 24 + 8 * techCoreLevel + techValues.agilityAttack;
                            }
                            amount += physicalAttackBonus;
                            summary += `On a hit, deal ${amount} physical damage to the target. `;
                            break;
                        case 'spirit':
                            if(specialAttack && techCore == 'damage') {
                                amount = 12 + 4 * techCoreLevel + Math.ceil(techValues.spiritAttack / 2);
                            } else if((!specialAttack && techCore == 'damage') || (specialAttack && techCore == 'ultDamage')) {
                                amount = 15 + 5 * techCoreLevel + techValues.spiritAttack;
                            } else {
                                amount = 24 + 8 * techCoreLevel + techValues.spiritAttack;
                            }
                            amount += energyAttackBonus;
                            summary += `On a hit, deal ${amount} energy damage to the target. `;
                            defRes = 'res';
                            break;
                        case 'mind':
                            if(specialAttack && techCore == 'damage') {
                                amount = 12 + 4 * techCoreLevel + Math.ceil(techValues.mindAttack / 2);
                            } else if((!specialAttack && techCore == 'damage') || (specialAttack && techCore == 'ultDamage')) {
                                amount = 15 + 5 * techCoreLevel + techValues.mindAttack;
                            } else {
                                amount = 24 + 8 * techCoreLevel + techValues.mindAttack;
                            }
                            amount += energyAttackBonus;
                            summary += `On a hit, deal ${amount} energy damage to the target. `;
                            defRes = 'res';
                            break;
                    }
                    break;
                case 'healing':
                    switch(techStat) {
                        case 'spirit':
                            amount = Math.ceil(spirit / 2); // ERRATA - Reduced Healing power
                            break;
                        case 'mind':
                            amount = Math.ceil(mind / 2);
                            break;
                        case 'guts':
                            amount = Math.ceil(guts / 2);
                            break;
                    }
                    if(techValues.healerLevel > 0) {
                        amount += 2 + 2 * techValues.healerLevel;
                    }
                    if(techMods.indexOf('continuous r') > -1) {
                        amount += 6 + 2 * techCoreLevel;
                        if(techValues.type == 'flunky' || techValues.type == 'soldier') amount = Math.ceil(amount / 2);
                        summary += `Makes the target recover ${amount} Health per turn for 3 turns. `;
                    } else {
                        amount += 9 + 3 * techCoreLevel;
                        if(techValues.type == 'flunky' || techValues.type == 'soldier') amount = Math.ceil(amount / 2);
                        summary += `Restore ${amount} Health to the target. `;
                    }
                    break;
                case 'barrier':
                    summary += `Create a Barrier of power ${techCoreLevel}. `;
                    barrierFreebie = true;
                    break;
                case 'mimic':
                    summary += `Mimics a witnessed enemy Technique at Tech Level ${techCoreLevel}. `;
                    break;
                case 'ultMimic':
                    summary += `Mimics a witnessed enemy Ultimate Technique at Tech Level ${techCoreLevel}. `;
                    break;
                case 'summoning':
                    summary += `Summons a Level ${techCoreLevel} ally. Command it with a Support Action. `;
                    break;
                case 'ultTransform':
                    amount = level * 10;
                    if(techValues.type == 'master') {
                        amount *= 2;
                    }
                    summary += `Transform, gaining ${amount} HP and +1 to all Active Attributes. `;
                    if(techGrantedSkills) {
                        summary += `Grants Skills: ${techGrantedSkills}`;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    hasSkills = true;
                    break;
                case 'boost':
                    if(techGrantedSkills) {
                        summary += `Grants Skills: ${techGrantedSkills}`;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    hasSkills = true;
                    break;
                case 'weaken':
                    if(techInflictedFlaws) {
                        summary += `Inflicts Flaws: ${techInflictedFlaws};`
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    hasFlaws = true;
                    break;
                case 'domain':
                    if(techGrantedSkills) {
                        summary += `Grants Skills within domain: ${techGrantedSkills}`;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    if(techInflictedFlaws) {
                        summary += ` Inflicts Flaws within domain: ${techInflictedFlaws}`;
                        if(!summary.endsWith('.')) {
                            summary += '.';
                        }
                        summary += ' ';
                    }
                    hasSkills = true;
                    hasFlaws = true;
                    break;
                case 'custom':
                    hasSkills = true;
                    hasFlaws = true;
                    break;
                default:
                    warnings.push(`Unknown Core '${techCore}'.`);
                    break;
            }
            summary += '\n';

            // Display mods
            let totalModLevel = 0;
            let mods = techMods.split('\n');
            mods.forEach(function(mod) {
                // Try to get the level
                let split = mod.split(' ');
                let modLevel = parseInt(split[split.length - 1]);
                if(modLevel != modLevel) {
                    // NaN, so there's no level listed - assume 1
                    modLevel = 1;
                }

                if(mod.indexOf('custom') == 0) {
                    totalModLevel += modLevel;
                } else if(mod.indexOf('range') == 0) {
                    log(mod);
                    let range = 3 * modLevel;
                    switch(techStat) {
                        case 'strength':
                            range = 2 * modLevel;
                            break;
                        case 'agility':
                        case 'spirit':
                            range = 4 * modLevel;
                            break;
                    }
                    summary += `Range ${range}. `;
                    totalModLevel += modLevel;
                    log(summary);
                } else if(mod.indexOf('blast') == 0) {
                    let rushMod = mods.find(function(m) {
                      return m.indexOf('line') > -1;
                    });
                    if(rushMod) {
                        // Say nothing - this'll get incorporated into the line attack mod
                    } else {
                        summary += `Blast Radius ${modLevel}. `;
                    }
                    let blastCost = 0;
                    if(techStat == 'spirit') {
                        blastCost = 2 * modLevel - 1;
                    } else {
                        blastCost = 2 * modLevel;
                    }
                    if(barrierFreebie) {
                        blastCost -= 2;
                        if(blastCost < 0) {
                            blastCost = 0;
                        }
                        barrierFreebie = false;
                    }
                    totalModLevel += blastCost;
                } else if(mod.indexOf('chain') == 0) {
                    if(modLevel == 1) {
                        summary += 'Chains once. ';
                    } else if(modLevel == 2) {
                        summary += 'Chains twice. ';
                    } else {
                        summary += `Chains ${modLevel} times. `;
                    }
                    totalModLevel += modLevel;
                } else if(mod.indexOf('line') == 0 && mod.indexOf('line var') != 0) {
                    let line = 3 * modLevel;
                    switch(techStat) {
                        case 'strength':
                        case 'agility':
                            line = 2 * modLevel;
                            break;
                        case 'spirit':
                            line++;
                            break;
                    }

                    let blastMod = mods.find(function(m) {
                      return m.indexOf('blast') == 0;
                    });
                    if(blastMod) {
                        // Incorporate blast radius into line attack
                        let blastSplit = blastMod.split(' ');
                        let blastRadius = parseInt(blastSplit[blastSplit.length - 1]);
                        if(blastRadius != blastRadius) {
                            // NaN, so there's no level listed - assume 1
                            blastRadius = 1;
                        }
                        summary += `Targets everything within radius ${blastRadius} around a line of length ${line}. `;
                    } else {
                        summary += `Targets in a line of length ${line}. `;
                    }
                    totalModLevel += modLevel;
                    if(barrierFreebie) {
                        totalModLevel--;
                        barrierFreebie = false;
                    }
                } else if(mod.indexOf('line var') == 0) {
                    let variations = modLevel;
                    if(techStat == 'mind') {
                        variations++;
                    }
                    if(variations == 1) {
                        summary += 'Line can change direction once. ';
                    } else {
                        summary += `Line can change direction ${variations} times. `;
                    }
                    totalModLevel += modLevel;
                } else if(mod.indexOf('multiple') == 0) {
                    let targets = 1 + modLevel;
                    if(techStat == 'agility') {
                        targets++;
                    }
                    summary += `Choose up to ${targets} targets. `;
                    totalModLevel += modLevel;
                } else if(mod.indexOf('indirect') == 0) {
                    summary += 'Can target anywhere on the battlefield. ';
                    totalModLevel += 3;
                } else if(mod.indexOf('rush') == 0) {
                    summary += 'Take a Move Action, then target everyone you moved through. ';
                    let dashMod = mods.find(function(m) {
                      return m.indexOf('dash') > -1;
                    });
                    if(dashMod) {
                      // Incorporate dash mod into rush attack
                      let dashSplit = dashMod.split(' ');
                      let bonusMove = parseInt(dashSplit[dashSplit.length - 1]);
                      if(bonusMove != bonusMove) {
                          // NaN, so there's no level listed - assume 1
                          bonusMove = 1;
                      }
                      if(techStat == 'agility') {
                          bonusMove++;
                      }
                      if(bonusMove == 1) {
                          summary += 'You can move an additional space on this Move Action. ';
                      } else {
                          summary += `You can move an additional ${bonusMove} spaces on this Move Action. `;
                      }
                    }
                    if(techStat == 'agility' || techStat == 'strength') {
                        totalModLevel += 2;
                    } else {
                        totalModLevel += 3;
                    }
                } else if(mod.indexOf('smart area') == 0) {
                    summary += 'You can choose to omit any number of spaces from the target area. ';
                    if(techStat == 'mind') {
                        totalModLevel++;
                    } else {
                        totalModLevel += 2;
                    }
                } else if(mod.indexOf('whirlwind') == 0) {
                    summary += 'Targets all enemies in your Zone of Control. ';
                    if(techStat == 'strength' || techStat == 'agility') {
                        totalModLevel++;
                    } else {
                        totalModLevel += 2;
                    }
                } else if(mod.indexOf('debilitating') == 0) {
                    if(techInflictedFlaws) {
                        summary += `Inflicts Flaws on a hit: ${techInflictedFlaws}. `;
                    }
                    hasFlaws = true;
                } else if(mod.indexOf('boosting') == 0) {
                    hasSkills = true;
                } else if(mod.indexOf('drain') == 0) {
                    summary += 'On a hit, recover Health equal to the largest amount of damage dealt to a single target. ';
                } else if(mod.indexOf('persistent') == 0) {
                    summary += 'Attacks again in the same area at the start of your next 2 turns. ';
                    isPersistent = true;
                } else if(mod.indexOf('piercing') == 0) {
                    if(techStat == 'strength' || techStat == 'agility') {
                        summary += 'Ignores Defense. ';
                    } else {
                        summary += 'Ignores Resistance. ';
                    }
                    defRes = null;
                } else if(mod.indexOf('sapping') == 0) {
                    summary += 'On a hit, the target takes ongoing damage equal to a third of initial damage for 3 turns. ';
                } else if(mod.indexOf('transform ally') == 0) {
                    summary += 'Can transform an ally within 5 spaces. ';
                    totalModLevel += 1;
                } else if(mod.indexOf('unerring') == 0) {
                    summary += 'Can be used again if you miss every target. ';
                    totalModLevel += 2;
                } else if(mod.indexOf('consecutive transform') == 0) {
                    summary += 'Can stack with another Transformation. ';
                    totalModLevel += modLevel;
                } else if(mod.indexOf('intimidating transform') == 0) {
                    summary += `When transforming and at the start of each turn, roll Resolve (1d10+${techValues.resolve}) or Aura (1d10+${techValues.aura})` +
                    ` to intimidate everyone within ${modLevel} spaces.`;
                    totalModLevel += modLevel;
                } else if(mod.indexOf('accurate') == 0) {
                    if(techStat == 'agility') {
                        totalModLevel += 3;
                    } else {
                        totalModLevel += 4;
                    }
                } else if(mod.indexOf('aura') == 0) {
                    totalModLevel++;
                } else if(mod.indexOf('damage shift') == 0) {
                    if(techStat == 'strength' || techStat == 'agility') {
                        summary += 'Is affected by Resistance instead of Defense. ';
                        defRes = 'res';
                    } else {
                        summary += 'Is affected by Defense instead of Resistance. ';
                        defRes = 'def';
                    }
                    totalModLevel++;
                } else if(mod.indexOf('darkness zone') == 0) {
                    summary += 'Target area is filled with darkness. ';
                    totalModLevel += 2;
                } else if(mod.indexOf('dash') == 0) {
                    let rushMod = mods.find(function(m) {
                      return m.indexOf('rush') > -1;
                    });
                    if(rushMod) {
                        // Say nothing - this'll get incorporated into the rush mod
                    } else {
                        let distance = modLevel;
                        if(techStat == 'agility') {
                            distance++;
                        }
                        if(distance == 1) {
                            summary += 'Move 1 space before or after attacking. ';
                        } else {
                            summary += `Move ${distance} spaces before or after attacking. `;
                        }
                    }
                    totalModLevel += modLevel;
                } else if(mod.indexOf('destruction') == 0) {
                    let destroy = 2 * modLevel;
                    summary += `+${destroy} Durability damage to objects. `;
                    totalModLevel++;
                } else if(mod.indexOf('dexterous') == 0 ||
                          mod.indexOf('dextrous') == 0) {
                    totalModLevel++;
                } else if(mod.indexOf('drop') == 0) {
                    summary += `If target is flying, they fall and take ${damageIncrement} damage. `;
                    totalModLevel++;
                } else if(mod.indexOf('grant flaw') == 0 ||
                          mod.indexOf('grants flaw') == 0) {
                    if(techInflictedFlaws) {
                        summary += `Inflicts Flaws: ${techInflictedFlaws}. `;
                    }
                    totalModLevel += modLevel;
                    hasFlaws = true;
                } else if(mod.indexOf('grant skill') == 0 ||
                          mod.indexOf('grants skill') == 0) {
                    if(techGrantedSkills) {
                        summary += `Grants Skills: ${techGrantedSkills}. `;
                    }
                    totalModLevel += modLevel;
                    hasSkills = true;
                } else if(mod.indexOf('high barrier') == 0) {
                    summary += 'Flying targets cannot cross the barrier. ';
                    totalModLevel ++;
                } else if(mod.indexOf('immobiliz') == 0) {
                    summary += 'On a hit, the target is Immobilized. ';
                    totalModLevel += 3;
                } else if(mod.indexOf('intuitive') == 0) {
                    totalModLevel++;
                } else if(mod.indexOf('knock') == 0) {
                    summary += 'On a hit, the target is knocked prone. ';
                    totalModLevel += 3;
                } else if(mod.indexOf('light zone') == 0) {
                    summary += 'Darkness in the target area is eliminated. ';
                    totalModLevel++;
                } else if(mod.indexOf('muscular') == 0) {
                    totalModLevel++;
                } else if(mod.indexOf('ram') == 0) {
                    summary += 'On a hit, move and drag the target to a space adjacent to you. ';
                    if(techStat == 'strength') {
                        totalModLevel++;
                    } else {
                        totalModLevel += 2;
                    }
                } else if(mod.indexOf('repo') == 0) {
                    let distance = 1 + modLevel;
                    if(techStat == 'strength') {
                        distance++;
                    }
                    summary += `On a hit, move the target up to ${distance} spaces. `;
                    totalModLevel += modLevel;
                } else if(mod.indexOf('throw') == 0) {
                    summary += 'If you move the target into someone else, attack them as well to deal full damage. ';
                    if(techStat == 'strength') {
                        totalModLevel++;
                    } else {
                        totalModLevel += 2;
                    }
                } else if(mod.indexOf('violent') == 0) {
                    summary += `If someone tries to move through the barrier, they take ${damageIncrement} damage. `;
                    totalModLevel++;
                } else if(mod.indexOf('launching') == 0) {
                    summary += 'On a hit, the target is Launched. ';
                    totalModLevel += 3;
                } else if(mod.indexOf('phasing') == 0) {
                    summary += 'Ignores all obstacles. ';
                    totalModLevel++;
                } else if(mod.indexOf('quick summon') == 0) {
                    totalModLevel += 3;
                } else if(mod.indexOf('selective barrier') == 0) {
                    summary += 'Allies can move through the barrier freely. ';
                    totalModLevel++;
                } else if(mod.indexOf('disrupt') >= 0) {
                    summary += 'Target area becomes Difficult Terrain. ';
                    totalModLevel++;
                } else if(mod.indexOf('repair') >= 0) {
                    summary += 'Difficult Terrain in the target area is eliminated. ';
                    totalModLevel++;
                } else if(mod.indexOf('element') == 0) {
                    summary += 'Deals elemental damage. ';
                    if(techStat == 'strength' || techStat == 'agility') {
                        totalModLevel++;
                    }
                } else if(mod.indexOf('defeat lock') == 0) {
                    summary += "If target is incapacitated, they can't be revived for 24 hours unless this character is defeated. ";
                    totalModLevel += 3;
                } else if(mod.indexOf('draw out the dark') == 0) {
                    summary += "On a hit, targets with Malevolent Entity must make a roll to maintain control. ";
                    totalModLevel += 1;
                } else if(mod.indexOf('effect lock') == 0) {
                    summary += "If centered on a target, the area of effect follows them as they move. ";
                    totalModLevel += 2;
                } else if(mod.indexOf('encroaching mal') == 0) {
                    summary += "On a hit, the target gains 1 Malevolence. ";
                    totalModLevel += 1;
                } else if(mod.indexOf('intimidat') == 0) {
                    summary += "On a hit, the target is Shaken. ";
                    totalModLevel += 3;
                } else if(mod.indexOf('overwhelming mal') == 0) {
                    summary += "On a hit, the target gains 1 Malevolence that lasts until the next rest scene. ";
                    totalModLevel += 3;
                } else if(mod.indexOf('pull under') == 0) {
                    summary += "On a hit, the target is dragged underwater. ";
                    totalModLevel += 2;
                } else if(mod.indexOf('repair') == 0) {
                    summary += "Can heal undead and constructs. ";
                    totalModLevel += 2;
                } else if(mod.indexOf('targeting mark') == 0) {
                    summary += "On a hit, Mark the target, giving your allies +1 to hit that target for 3 turns. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('astral form') == 0) {
                    summary += "Project an astral body into the center of the domain; you can attack from it and it projects a Zone of Control. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('astral mo') == 0) {
                    summary += "Your astral body can move within your domain whenever you move. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('influential control') == 0) {
                    if(limitLevel == 1) {
                        summary += "Your zone of control is expanded by 1 space within your domain. ";
                    } else {
                        summary += `Your zone of control is expanded by ${limitLevel} spaces within your domain. `;
                    }
                    totalModLevel += 6 * limitLevel;
                } else if(mod.indexOf('locked zone') == 0) {
                    summary += "Characters must succeed at an opposed roll against you to exit your domain. Attacks across the edge of the domain are made at a -2 penalty. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('shifting tran') == 0) {
                    summary += "Switch to another form and replace one of its Transformations with this one. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('shifting dom') == 0) {
                    summary += "Switch to another form and replace one of its Domains with this one. ";
                    totalModLevel += 4;
                } else if(mod.indexOf('touch of mal') == 0) {
                    summary += "Whenever you hit a target with a Damage or Weaken tech in this form, they gain 1 Malevolence. ";
                    totalModLevel += 6;
                } else if(mod.indexOf('continuous r') == 0) {
                    // Add nothing, already explained in core description
                } else if(mod.length > 0) {
                    warnings.push(`Unrecognized Modifier '${mod}'.`);
                }
            });
            if(techCore == 'ultDamage' || techCore == 'domain') {
                totalModLevel -= 2;
                if(totalModLevel < 0) totalModLevel = 0;
                totalModLevel = Math.ceil(totalModLevel / 2);
            }

            let techLevel = techCoreLevel + totalModLevel;
            if(techLevel > level + 3 || (techCoreLevel > level && techCore == 'summoning')) {
                warnings.push('Technique Level is too high for current Character Level.');
            }

            summary += '\n';
            // Display the technique cost and limits
            let core = coreLibrary.find(function(c) {
                return c.id == techCore;
            });

            let limitSummary = '';
            let limitSt = 0;
            let limits = techLimits.split('\n');
            limits.forEach(function(limit) {
                // Try to get the level
                let split = limit.split(' ');
                let limitLevel = parseInt(split[split.length - 1]);
                if(limitLevel != limitLevel) {
                    // NaN, so there's no level listed - assume 1
                    limitLevel = 1;
                }

                if(limit.indexOf('custom') == 0) {
                    limitSt += limitLevel;
                } else if(limit.indexOf('health') == 0) {
                    let healthLost = 5 * limitLevel;
                    limitSummary += `Costs ${healthLost} Health. `;
                    limitSt += 2 * limitLevel;
                    if(limitLevel > 5) {
                        warnings.push("Health Limit can't be taken above level 5.");
                    }
                } else if(limit.indexOf('ally') == 0) {
                    limitSummary += 'Cannot target yourself. ';
                    limitSt++;
                } else if(limit.indexOf('ammo') == 0 ||
                          limit.indexOf('ammunition') == 0) {
                    let ammo = 4 - limitLevel;
                    if(ammo == 1) {
                        limitSummary += 'Can only be used once per scene. ';
                    } else {
                        limitSummary += `Can only be used ${ammo} times per scene. `;
                    }
                    limitSt += 3 * limitLevel;
                } else if(limit.indexOf('companion') == 0) {
                    limitSummary += 'Only your Companion can use this Technique. ';
                    limitSt += 2;
                } else if(limit.indexOf('cooldown') == 0) {
                    if(limitLevel == 1) {
                        limitSummary += 'Must wait for 1 turn before using again. ';
                    } else {
                        limitSummary += `Must wait for ${limitLevel} turns before using again. `;
                    }
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('dark power') == 0) {
                    limitSummary += 'When you use this Technique, make a Malevolent Entity check. ';
                    limitSt += 10;
                } else if(limit.indexOf('form') == 0) {
                    limitSummary += 'You must be transformed to use this Technique. ';
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('falling') == 0) {
                    limitSummary += 'Fall prone after using this Technique. ';
                    limitSt += 4;
                } else if(limit.indexOf('grant flaw') == 0) {
                    if(techInflictedFlaws) {
                        summary += `Inflicts Flaws on user: ${techInflictedFlaws}. `;
                    }
                    limitSt += limitLevel;
                    hasFlaws = true;
                } else if(limit.indexOf('grant skill') == 0) {
                    if(techGrantedSkills) {
                        summary += `Grants Skills for target: ${techGrantedSkills}. `;
                    }
                    limitSt += limitLevel;
                    hasSkills = true;
                } else if(limit.indexOf('initiative') == 0) {
                    limitSummary += `Initiative reduced by ${limitLevel} after using this Technique. `;
                    limitSt += 3 * limitLevel;
                } else if(limit.indexOf('immobile') == 0) {
                    limitSummary += "Can't be used if you've already moved this turn. ";
                    limitSt += 3;
                } else if(limit.indexOf('injury') == 0) {
                    let threshold = health - Math.ceil(health / 5) * limitLevel;
                    limitSummary += `Your Health must be ${threshold} or lower to use this Technique. `;
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('landbound') == 0) {
                    limitSummary += 'Cannot target flying characters. ';
                    limitSt++;
                } else if(limit.indexOf('mercy') == 0) {
                    limitSummary += 'Cannot reduce a target below 1 HP. ';
                    limitSt += 3;
                } else if(limit.indexOf('minimum range') == 0) {
                    limitSummary += `Cannot target characters who are ${limitLevel} or fewer spaces away from you. `;
                    limitSt += limitLevel;
                } else if(limit.indexOf('movement') == 0) {
                    if(limitLevel == 1) {
                        limitSummary += "Can't be used unless you're at least 1 space away from where you started your turn. ";
                    } else {
                        limitSummary += `Can't be used unless you're at least ${limitLevel} spaces away from where you started your turn. `;
                    }
                    limitSt += limitLevel;
                } else if(limit.indexOf('push') == 0) {
                    limitSummary += 'Each space of movement must move the target further away from you. ';
                    limitSt++;
                } else if(limit.indexOf('pull') == 0) {
                    limitSummary += 'Each space of movement must move the target closer to you. ';
                    limitSt++;
                } else if(limit.indexOf('reaction') == 0) {
                    limitSummary += 'Can only be used with the Counterattack skill. ';
                    limitSt += 3;
                } else if(limit.indexOf('reload') == 0) {
                    limitSummary += 'Must use a Support Action to reload before using again. ';
                    limitSt += 4;
                } else if(limit.indexOf('sequence') == 0) {
                    limitSummary += 'Must use a specific other Technique before using this one. ';
                    limitSt += 4;
                } else if(limit.indexOf('self') == 0) {
                    limitSummary += 'Can only target yourself. ';
                    limitSt++;
                } else if(limit.indexOf('setup') == 0 ||
                          limit.indexOf('set-up') == 0 ||
                          limit.indexOf('set up') == 0) {
                    let turn = 1 + limitLevel;
                    limitSummary += `Can't be used until turn ${turn} or later. `;
                    limitSt += limitLevel;
                } else if(limit.indexOf('single companion') == 0) {
                    limitSummary += 'Only a specific Companion can use this Technique. ';
                    limitSt += 3;
                } else if(limit.indexOf('slow') == 0) {
                    limitSt += 6;
                } else if(limit.indexOf('temporary') == 0) {
                    limitSummary += 'Only lasts for 2 turns. ';
                    limitSt += 6;
                } else if(limit.indexOf('unstable summon') == 0) {
                    limitSummary += `Summon has a ${limitLevel} in 10 chance to ignore orders. `;
                    limitSt += 4 * limitLevel;
                } else if(limit.indexOf('upkeep') == 0) {
                    limitSummary += `Must spent ${limitLevel} Stamina at the start of each turn to keep active. `;
                    limitSt += 4 * limitLevel;
                } else if(limit.indexOf('vitality') == 0) {
                    let threshold = Math.ceil(health * 0.4);
                    limitSummary += `Can't be used if you are at or below ${threshold} Health. `;
                    limitSt += 3 * limitLevel;
                } else if(limit.indexOf('valor') == 0) {
                    if(limit.indexOf('valor consumption') > -1) {
                        limitSummary += `Valor is reduced by ${limitLevel} after using (can go below 0). `;
                        limitSt += 5 * limitLevel;
                    } else {
                        limitSummary += `Can't be used unless you have at least ${limitLevel} Valor. `;
                        limitSt += 2 * limitLevel;
                    }
                } else if(limit.indexOf('clone') == 0) {
                    limitSummary += 'You must have an active Clone to use this Technique. ';
                    limitSt += 2;
                } else if(limit.indexOf('node sacrifice') == 0) {
                    limitSummary += 'Must originate from an Attack Node, and the node is destroyed. ';
                    limitSt += 8;
                } else if(limit.indexOf('refraction') == 0) {
                    limitSummary += 'Must pass through a Refraction Point to take effect. ';
                    limitSt += 2;
                } else if(limit.indexOf('time') == 0) {
                    let time = 5 - limitLevel;
                    limitSummary += `Transformation ends after ${time} ${time == 1 ? 'turn' : 'turns'}. `;
                    limitSt += 5 * limitLevel;
                } else if(limit.indexOf('airborne') == 0) {
                    limitSummary += 'You must be Flying to use this Technique. ';
                    limitSt++;
                } else if(limit.indexOf('drop') == 0) {
                    limitSummary += 'You cease Flying after using this Technique. ';
                    limitSt += 4;
                } else if(limit.indexOf('revert') == 0) {
                    limitSummary += 'Your Transformation ends when you use this Technique. ';
                    limitSt += 10;
                } else if(limit.indexOf('ultimate cooldown') == 0) {
                    if(limitLevel == 1) {
                        limitSummary += "After using this Technique, you can't use it during the next scene. ";
                    } else {
                        limitSummary += `After using this Technique, you can't use it during the next ${limitLevel} scenes. `;
                    }
                    limitSt += 10 * limitLevel;
                } else if(limit.indexOf('ultimate health') == 0) {
                    damage = Math.ceil(health / 5);
                    limitSummary += `Costs ${damage} Health. `;
                    limitSt += 20;
                } else if(limit.indexOf('ultimate valor') == 0) {
                    limitSummary += `Costs ${limitLevel} Valor. `;
                    limitSt += 10 * limitLevel;
                } else if(limit.indexOf('dark surrender') == 0) {
                    limitSummary += 'After using this Technique, you automatically surrender to your Malevolent Entity. ';
                    limitSt += 30;
                } else if(limit.indexOf('final') == 0) {
                    limitSummary += 'After using this Technique, your Health and Valor are both reduced to 0. ';
                    limitSt = 9999;
                } else if(limit.indexOf('sacrifice') == 0) {
                    limitSummary += `Costs ${10 * limitLevel} of an ally's Health. `;
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('fatigue') == 0) {
                    limitSummary += 'You become Fatigued after using this Technique. ';
                    limitSt += 15;
                } else if(limit.indexOf('weapon req') == 0) {
                    limitSummary += 'You must be holding your weapon to use this Technique. ';
                    limitSt += 3;
                } else if(limit.indexOf('weapon rel') == 0) {
                    limitSummary += "-10 damage if you aren't holding your weapon. ";
                    limitSt += 1;
                } else if(limit.indexOf('expendable') == 0) {
                    limitSummary += 'Consumes ammunition that must be purchased or found. ';
                    limitSt += limitLevel;
                } else if(limit.indexOf('sync') == 0) {
                    limitSummary += `You must have at least ${limitLevel} Synchronization with your Ego Weapon to use this Technique. `;
                    limitSt += 2 * limitLevel;
                } else if(limit.indexOf('bloodseeker') == 0) {
                    limitSummary += 'Can only affect targets that are at Critical Health. ';
                    limitSt += 3;
                } else if(limit.indexOf('body strike') == 0) {
                    limitSummary += "Can only be used from your body. ";
                    limitSt += 1;
                } else if(limit.indexOf('elemental block') == 0) {
                    limitSummary += "Can't be used if you took damage from a specific element since your last turn. ";
                    limitSt += 2;
                } else if(limit.indexOf('exclusive') == 0) {
                    limitSummary += "Cancels out a specific other technique's effects when used. ";
                    limitSt += 1;
                } else if(limit.indexOf('head strike') == 0) {
                    limitSummary += "Can only be used from your head. ";
                    limitSt += 1;
                } else if(limit.indexOf('skill cancel') == 0) {
                    limitSummary += "When active, you lose a specific Skill. ";
                    limitSt += limitLevel;
                } else if(limit.indexOf('tail strike') == 0) {
                    limitSummary += "Can only be used from your tail. ";
                    limitSt += limitLevel;
                } else if(limit.indexOf('water') == 0) {
                    limitSummary += "Can only be used underwater. ";
                    limitSt += 3;
                } else if(limit.length > 0 &&
                          limit.indexOf('slow') == -1 &&
                          limit.indexOf('grant') == -1) {
                    warnings.push(`Unrecognized Limit '${limit}'.`);
                }
            });

            let cost = 0;
            if((core || techCore == 'custom') && techCore != 'mimic' && techCore != 'ultMimic') {
                if(techCore == 'custom') {
                    cost = techCustomCost;
                } else {
                    cost = core.cost + core.levelUp * (techCoreLevel + totalModLevel) - limitSt;
                }
                if(cost < 0) {
                    cost = 0;
                }

                summary += `Costs ${cost} Stamina. `
            }
            summary += limitSummary;

            // Determine Flaw SP
            let flawSpMax = 0;
            let flawSp = 0;
            if(hasFlaws) {
                switch(techCore) {
                    case 'weaken':
                    case 'domain':
                    case 'damage':
                        flawSpMax = techCoreLevel;
                        break;
                }
                const techFlawList = techInflictedFlaws.toLowerCase()
                    .split(',')
                    .map(s => {
                        if(s && s.length > 0) {
                            // Try to split out the flaw level
                            let split = s.split(' ');
                            let flawLevel = parseInt(split[split.length - 1]);
                            if(flawLevel != flawLevel) {
                                // NaN, so there's no level listed
                                return {
                                    name: s.trim(),
                                    level: 1
                                };
                            } else {
                                return {
                                    name: split.slice(0, split.length - 1).join(' ').trim(),
                                    level: flawLevel
                                };
                            }
                        } else {
                            return null;
                        }
                    })
                    .filter(s => s);
                
                for(const flaw of techFlawList) {
                    const flawData = flawLibrary.find(f => flaw.name.match(f.namePattern));
                    if(flawData) {
                        // Max flaw level
                        var flawMaxLevel = 1;
                        switch(flawData.speed) {
                            case 1:
                                flawMaxLevel = Math.ceil(level / 5);
                                break;
                            case 2:
                                flawMaxLevel = Math.ceil(level / 3);
                                break;
                            case 3:
                                flawMaxLevel = 100; // Custom Flaw
                        }
                        if(flaw.level > flawMaxLevel) {
                            warnings.push(`Max level for Flaw '${flaw.name}' is ${flawMaxLevel}.`);
                        }
                        
                        flawSp += flawData.cost + flawData.levelUp * (flaw.level - 1);
                    } else {
                        warnings.push(`Unrecognized Flaw '${flaw.name}'.`);
                    }
                }
                if(flawSp > flawSpMax && flawSpMax > 0) {
                    warnings.push('Flaws exceed SP limit.');
                }
            }

            // Determine Skill SP
            let skillSpMax = 0;
            let skillSp = 0;
            if(hasSkills) {
                switch(techCore) {
                    case 'boost':
                    case 'ultTransform':
                    case 'domain':
                        skillSpMax = 2 * techCoreLevel;
                        break;
                }
                const techSkillList = techGrantedSkills.toLowerCase()
                    .split(',')
                    .map(s => {
                        if(s && s.length > 0) {
                            // Try to split out the flaw level
                            let split = s.split(' ');
                            let skillLevel = parseInt(split[split.length - 1]);
                            if(skillLevel != skillLevel) {
                                // NaN, so there's no level listed
                                return {
                                    name: s.trim(),
                                    level: 1
                                };
                            } else {
                                return {
                                    name: split.slice(0, split.length - 1).join(' ').trim(),
                                    level: skillLevel
                                };
                            }
                        } else {
                            return null;
                        }
                    })
                    .filter(s => s);
                for(const skill of techSkillList) {
                    const skillData = skillLibrary.find(s => skill.name.match(s.namePattern));
                    if(skillData) {
                        // Max skill level
                        var skillMaxLevel = 1;
                        switch(skillData.speed) {
                            case 1:
                                skillMaxLevel = Math.ceil(level / 5);
                                break;
                            case 2:
                                skillMaxLevel = Math.ceil(level / 3);
                                break;
                            case 3:
                                skillMaxLevel = 100; // Custom Flaw
                        }
                        if(skill.level > skillMaxLevel) {
                            warnings.push(`Max level for Skill '${skill.name}' is ${skillMaxLevel}.`);
                        }
                        
                        skillSp += skillData.cost + skillData.levelUp * (skill.level - 1);
                    } else {
                        warnings.push(`Unrecognized Skill '${skill.name}''.`);
                    }
                }
                if(skillSp > skillSpMax && skillSpMax > 0) {
                    warnings.push('Skills exceed SP limit.');
                }
            }
            
            // Write the small summary
            switch(techCore) {
                case 'damage':
                case 'ultDamage':
                    microSummary = `Damage: **${amount}**`;
                    if(defRes) microSummary += ` - ${defRes == 'def' ? 'Defense' : 'Resistance'}`;
                    break;
                case 'healing':
                    microSummary = `Restores **${amount}** HP`;
                    break;
                case 'ultTransform':
                    microSummary = `HP +**${amount}**`;
                    break;
            }
            
            let attrs = {};
            attrs[`repeating_techs_${techId}_tech_summary`] = summary;
            attrs[`repeating_techs_${techId}_tech_warnings`] = warnings.length > 0 ? `WARNING: ${warnings.join(' ')}` : ' ';
            attrs[`repeating_techs_${techId}_tech_mod_level`] = totalModLevel;
            attrs[`repeating_techs_${techId}_tech_level`] = techLevel;
            attrs[`repeating_techs_${techId}_tech_limit_st`] = limitSt;
            attrs[`repeating_techs_${techId}_tech_cost`] = cost;
            attrs[`repeating_techs_${techId}_tech_flaw_sp`] = flawSp;
            attrs[`repeating_techs_${techId}_tech_flaw_sp_max`] = flawSpMax;
            attrs[`repeating_techs_${techId}_tech_skill_sp`] = skillSp;
            attrs[`repeating_techs_${techId}_tech_skill_sp_max`] = skillSpMax;
            attrs[`repeating_techs_${techId}_tech_is_mimic`] = techCore == 'mimic' || techCore == 'ultMimic'
                ? 'on' : 'off';
            attrs[`repeating_techs_${techId}_tech_has_flaws`] = hasFlaws
                ? 'on' : 'off';
            attrs[`repeating_techs_${techId}_tech_has_skills`] = hasSkills
                ? 'on' : 'off';
            attrs[`repeating_techs_${techId}_tech_inflicted_flaws`] = hasFlaws ? techInflictedFlaws : '';
            attrs[`repeating_techs_${techId}_tech_granted_skills`] = hasSkills ? techGrantedSkills : '';
            if(techCore != 'mimic') {
                attrs[`repeating_techs_${techId}_tech_mimic_target`] = '';
            }
            attrs[`repeating_techs_${techId}_tech_can_edit_cost`] = techCore == 'custom' ? 'on' : 'off';
            attrs[`repeating_techs_${techId}_tech_stat_roll`] = techRoll;
            attrs[`repeating_techs_${techId}_tech_micro_summary`] = microSummary;
            setAttrs(attrs, { silent: true });
        });
    }

    on('change:level change:strength change:agility change:spirit change:mind change:guts', function() {
        calculateBaseAttributes();
    });

    on('change:level change:strength change:agility change:spirit change:mind change:guts ' +
        'change:type change:repeating_skills remove:repeating_skills', function() {
        calculateAttack();
        calculateActiveAttributes();

    });

    on('change:strengthattack change:agilityattack change:mindattack change:spiritattack ' +
        'change:patkbonus change:eatkbonus change:atkrollbonus change:iatkrollbonus change:rollbonus', function() {
        getSectionIDs('repeating_techs', function(tidarray) {
            tidarray.forEach(function(techId) {
                calculateTech(techId);
            });
        });
    });

    on('change:level change:strength change:guts change:type ' +
        'change:repeating_skills remove:repeating_skills change:repeating_flaws remove:repeating_flaws', function() {
        calculateHealth();
        calculateDefense();
    });

    on('change:level change:mind change:spirit change:type ' +
        'change:repeating_skills remove:repeating_skills change:repeating_flaws remove:repeating_flaws', function() {
        calculateStamina();
        calculateResistance();
    });

    on('change:agility change:repeating_skills remove:repeating_skills change:repeating_flaws remove:repeating_flaws', function() {
        calculateMove();
    });

    on('change:level change:type change:repeating_skills remove:repeating_skills', function() {
        calculateDamageIncrement();
    });

    on('change:dexterity change:repeating_skills remove:repeating_skills change:repeating_flaws remove:repeating_flaws', function() {
        calculateInitiative();
    });

    on('change:level change:type change:repeating_skills remove:repeating_skills ' +
        'change:repeating_flaws remove:repeating_flaws', function() {
        calculateFlawsAndSkills();
    });

    on('change:type change:repeating_skills remove:repeating_skills', function() {
        calculateBonuses();
    });

    on('change:level change:type change:repeating_skills remove:repeating_skills ' +
       'change:repeating_techs:tech_core_level change:repeating_techs:tech_mods change:repeating_techs:tech_core', function() {
        calculateTP();
    });

    on('change:repeating_techs:tech_name change:repeating_techs:tech_core_level ' +
       'change:repeating_techs:tech_core change:repeating_techs:tech_stat ' +
       'change:repeating_techs:tech_mods change:repeating_techs:tech_targets change:repeating_techs:tech_bonus ' +
       'change:repeating_techs:tech_limits change:repeating_techs:tech_description ' +
       'change:repeating_techs:tech_granted_skills change:repeating_techs:tech_inflicted_flaws ' +
       'change:repeating_techs:tech_custom_cost', function(eventInfo) {
        var techId = eventInfo.sourceAttribute.substring(16, 36);
        calculateTech(techId);
    });

    on('sheet:opened', function() {
        // Update attributes
        calculateBaseAttributes();
        calculateAttack();
        calculateActiveAttributes();
        calculateHealth();
        calculateDefense();
        calculateStamina();
        calculateResistance();
        calculateMove();
        calculateDamageIncrement();
        calculateInitiative();
        calculateFlawsAndSkills();
        calculateBonuses();
        calculateTP();

        // Update techs
        getSectionIDs('repeating_techs', function(tidarray) {
            tidarray.forEach(function(techId) {
                calculateTech(techId);
            });
        });
    });

</script>

<div class="sheet-container">
    <!-- Tabs -->
    <input type="radio" name="attr_tab" class="sheet-tab sheet-tab1" value="1" checked="checked"><span title="Attributes"></span>
    <input type="radio" name="attr_tab" class="sheet-tab sheet-tab2" value="2"><span title="Skills & Flaws"></span>
    <input type="radio" name="attr_tab" class="sheet-tab sheet-tab3" value="3"><span title="Techniques"></span>

    <div class="sheet-tab-content sheet-tab1">
        <!-- Sheet header -->
        <div class="attributes-header">
            <div class="attributes-header-label">
                <span class="label">Level:</span>
            </div>
            <div>
                <input class="attributes-header-input" type="number" name="attr_level" value="1">
            </div>
            <div class="attributes-header-label">
                <span class="label">Experience:</span>
            </div>
            <div>
                <input type="number" class="longer-number attributes-header-input" name="attr_experience" value="0">
            </div>
            <div class="attributes-header-label">
                <span class="label">Type:</span>
            </div>
            <div>
                <select name="attr_type" class="attributes-header-input">
                    <option value="flunky">Flunky</option>
                    <option value="soldier">Summon/Soldier</option>
                    <option value="swarm">Swarm</option>
                    <option value="elite" selected="selected">PC/Elite</option>
                    <option value="master">Master</option>
                </select>
            </div>
        </div>

        <!-- Attributes -->
        <div class="section-header">ATTRIBUTES</div>
        <div class="stats-container">
            <div class="stats">
                <div class="stats-column stats-orange">
                    <div class="label stats-column-header">BASE</div>
                    <div>Strength:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_strength" value="5">
                    </div>
                    <div>Agility:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_agility" value="5">
                    </div>
                    <div>Spirit:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_spirit" value="5">
                    </div>
                    <div>Mind:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_mind" value="5">
                    </div>
                    <div>Guts:</div>
                    <div>
                        <input type="number" class="number-input-orange" name="attr_guts" value="5">
                    </div>
                </div>
                <div class="stats-column stats-green">
                    <div class="label stats-column-header">ACTIVE</div>
                    <div>Muscle:</div>
                    <div>
                        <span class="derived-value" name="attr_muscle"></span>
                        <button type="roll" value='[[1d10+@{muscle}+@{rollbonus}]] Muscle' name="roll_muscle"></button>
                    </div>
                    <div>Dexterity:</div>
                    <div>
                        <span class="derived-value" name="attr_dexterity"></span>
                        <button type="roll" value='[[1d10+@{dexterity}+@{rollbonus}]] Dexterity' name="roll_dexterity"></button>
                    </div>
                    <div>Aura:</div>
                    <div>
                        <span class="derived-value" name="attr_aura"></span>
                        <button type="roll" value='[[1d10+@{aura}+@{rollbonus}]] Aura' name="roll_aura"></button>
                    </div>
                    <div>Intuition:</div>
                    <div>
                        <span class="derived-value" name="attr_intuition"></span>
                        <button type="roll" value='[[1d10+@{intuition}+@{rollbonus}]] Intuition' name="roll_intuition"></button>
                    </div>
                    <div>Resolve:</div>
                    <div>
                        <span class="derived-value" name="attr_resolve"></span>
                        <button type="roll" value='[[1d10+@{resolve}+@{rollbonus}]] Resolve' name="roll_resolve"></button>
                    </div>
                </div>
                <div class="stats-column stats-orange">
                    <div class="label stats-column-header">ATTACK</div>
                    <div>Strength:</div>
                    <div class="derived-value">
                        <span name="attr_strengthAttack" />
                    </div>
                    <div>Agility:</div>
                    <div class="derived-value">
                        <span name="attr_agilityAttack" />
                    </div>
                    <div>Spirit:</div>
                    <div class="derived-value">
                        <span name="attr_spiritAttack" />
                    </div>
                    <div>Mind:</div>
                    <div class="derived-value">
                        <span name="attr_mindAttack" />
                    </div>
                    <div>
                        <!-- No guts attack -->
                    </div>
                </div>
                <div class="stats-column stats-green">
                    <div class="label stats-column-header">STATISTICS</div>
                    <div>Health:</div>
                    <div class="derived-value">
                        <span name="attr_health_max" />
                    </div>
                    <div>Stamina:</div>
                    <div class="derived-value">
                        <span name="attr_stamina_max" />
                    </div>
                    <div>Defense:</div>
                    <div class="derived-value">
                        <span name="attr_defense" />
                    </div>
                    <div>Resistance:</div>
                    <div class="derived-value">
                        <span name="attr_resistance" />
                    </div>
                    <div>Move:</div>
                    <div class="derived-value">
                        <span name="attr_move" />
                    </div>
                </div>
                <div class="stats-column stats-orange">
                    <div class="label stats-column-header">INCREMENTS</div>
                    <div>HP Increment:</div>
                    <div class="derived-value">
                        <span name="attr_healthIncrement" />
                    </div>
                    <div>ST Increment:</div>
                    <div class="derived-value">
                        <span name="attr_staminaIncrement" />
                    </div>
                    <div>Critical HP:</div>
                    <div class="derived-value">
                        <span name="attr_criticalHealth" />
                    </div>
                    <div>Dmg Increment:</div>
                    <div class="derived-value">
                        <span name="attr_damageIncrement" />
                    </div>
                    <div>Initiative:</div>
                    <div class="derived-value">
                        <span name="attr_initiative" ></span>
                        <button type="roll" value="[[1d10+@{initiative}+@{rollbonus} &{tracker} &{noerror}]] Initiative" name="roll_init"></button>
                    </div>
                </div>
            </div>
        </div>
        <div class="unspent-ap"><span name="attr_unspentAttributePoints"></span> AP UNSPENT</div>
        <div class="section-header">BONUSES</div>
        <div class="stats-container">
            <div class="stats">
                <div class="stats-wide-column stats-green stats-short">
                    <div>All Rolls:</div>
                    <div>
                        <input type="number" class="number-input-green" name="attr_rollbonus" value="0">
                    </div>
                    <div></div>
                    <div>Attack Rolls:</div>
                    <div>
                        <input type="number" class="number-input-green" name="attr_atkrollbonus" value="0">
                    </div>
                    <div>
                        <span name="attr_iatkrollbonusdisp"></span>
                    </div>
                    <div>Defense Rolls:</div>
                    <div>
                        <input type="number" class="number-input-green" name="attr_defrollbonus" value="0">
                    </div>
                    <div>
                        <span name="attr_idefrollbonusdisp"></span>
                    </div>
                </div>
                <div class="stats-column stats-orange stats-short">
                    <div>Phys. Attack:</div>
                    <div>
                        <input type="number" class="number-input-orange long-number" name="attr_patkbonus" value="0">
                    </div>
                    <div>En. Attack:</div>
                    <div>
                        <input type="number" class="number-input-orange long-number" name="attr_eatkbonus" value="0">
                    </div>
                </div>
            </div>
        </div>
        <div class="section-header roll-defense">ROLL DEFENSE</div>
        <div class="defense-buttons">
            <button class="valor-button" type="roll" value='[[1d10+@{muscle}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}]] Muscle Defense' name="roll_mus_def">Muscle</button>
            <button class="valor-button" type="roll" value='[[1d10+@{dexterity}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}]] Dexterity Defense' name="roll_dex_def">Dexterity</button>
            <button class="valor-button" type="roll" value='[[1d10+@{aura}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}]] Aura Defense' name="roll_aur_def">Aura</button>
            <button class="valor-button" type="roll" value='[[1d10+@{intuition}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}]] Intuition Defense' name="roll_int_def">Intuition</button>
            <button class="valor-button" type="roll" value='[[1d10+@{resolve}+@{rollbonus}+@{defrollbonus}+@{idefrollbonus}]] Resolve Defense' name="roll_res_def">Resolve</button>
        </div>
    </div>

    <div class="sheet-tab-content sheet-tab2">
        <div class="flaws-header">FLAWS</div>
        <fieldset class="repeating_flaws">
            <div class="flaw">
                <div class="flaw-upper">
                    <select class="flaw-picker" name="attr_flawname" selected="customFlaw">
                        <option value="customFlaw">Custom Flaw</option>
                        <option value="aggravatedWounds">Aggravated Wounds (+2)</option>
                        <option value="berserker">Berserker (+5)</option>
                        <option value="compulsion">Compulsion (+4)</option>
                        <option value="despair">Despair (+4)</option>
                        <option value="energyVulnerability">Energy Vulnerability (+2/+1)</option>
                        <option value="feeble">Feeble (+3)</option>
                        <option value="fragile">Fragile (+3/+2)</option>
                        <option value="lackOfControl">Lack of Control (+2/+1)</option>
                        <option value="malevolentEntity">Malevolent Entity (+5)</option>
                        <option value="nonProficient">Non-Proficient (+1)</option>
                        <option value="oblivious">Oblivious (+3)</option>
                        <option value="slow">Slow (+2/+1)</option>
                        <option value="slowHealing">Slow Healing (+2)</option>
                        <option value="slowToAct">Slow to Act (+1)</option>
                        <option value="unthreatening">Unthreatening (+3)</option>
                        <option value="uncoordinated">Uncoordinated (+3)</option>
                        <option value="violent">Violent (+3)</option>
                        <option value="weakAura">Weak Aura (+3)</option>
                        <option value="weakDefender">Weak Defender (+2/+1)</option>
                        <option value="weakWilled">Weak Willed (+4/+3)</option>
                        <optgroup label="Optional Rules">
                            <option value="armorReliant">Armor Reliant (+2/+1)</option>
                            <option value="elementalVulnerability">Elemental Vulnerability (+2/+1)</option>
                            <option value="unprincipled">Unprincipled (+1)</option>
                            <option value="wardReliant">Ward Reliant (+2/+1)</option>
                        </optgroup>
                        <optgroup label="NPC Only">
                            <option value="battleDamage">Battle Damage (+3)</option>
                        </optgroup>
                        <optgroup label="Villains, Creatures and Foes (BETA)">
                            <option value="broadForm">Broad Form (+4)</option>
                            <option value="fearTheDarkness">Fear the Darkness (+3)</option>
                            <option value="immobile">Immobile (+7)</option>
                            <option value="insubstantial">Insubstantial (+3)</option>
                            <option value="situationalCompulsion">Situational Compulsion (+2)</option>
                            <option value="sunlightWeakness">Sunlight Weakness (+5)</option>
                            <option value="thresheld">Thresheld (+3)</option>
                            <option value="weakGuard">Weak Guard (+2)</option>
                            <option value="malevolentPossession">Malevolent Possession (+10)</option>
                        </optgroup>
                    </select>
                    <span class="label">
                        Level <input class="flaw-level" type="number" name="attr_flawlevel" value="1" />
                    </span>
                    <span name="attr_warning"></span>
                </div>
                <div><span class="label notes-label">Notes</span> <input class="notes" type="text" name="attr_skillnotes" /></div>
            </div>
            <div class="flaw-background"></div>
        </fieldset>

        <div class="skills-header">SKILLS</div>

        <fieldset class="repeating_skills">
            <div class="skill">
                <div class="skill-upper">
                    <select class="skill-picker" name="attr_skillname" selected="customSkill">
                        <option value="customSkill">Custom Skill</option>
                        <optgroup label="Season 1 Skills">
                            <option value="acceleration">Acceleration (5)</option>
                            <option value="analysis">Analysis (5)</option>
                            <option value="asset">Asset (3)</option>
                            <option value="attackNode">Attack Node (5/2)</option>
                            <option value="balancedFighter">Balanced Fighter (8)</option>
                            <option value="blazingMight">Blazing Might (6/3)</option>
                            <option value="bounceBack">Bounce Back (6)</option>
                            <option value="bravado">Bravado (6/6)</option>
                            <option value="burningPassion">Burning Passion (5)</option>
                            <option value="challengeTechnique">Challenge Technique (3)</option>
                            <option value="combinationAttack">Combination Attack (6)</option>
                            <option value="companion">Companion (6/4)</option>
                            <option value="counterattack">Counterattack (6)</option>
                            <option value="cover">Cover (6/2)</option>
                            <option value="crisis">Crisis (4/2)</option>
                            <option value="dangerSense">Danger Sense (3)</option>
                            <option value="darkHealing">Dark Healing (5)</option>
                            <option value="darksight">Darksight (4)</option>
                            <option value="desperation">Desperation (5)</option>
                            <option value="digDeep">Dig Deep (5)</option>
                            <option value="dirtyTrick">Dirty Trick (5)</option>
                            <option value="discreetAura">Discreet Aura (3)</option>
                            <option value="discretion">Discretion (2)</option>
                            <option value="duel">Duel (2)</option>
                            <option value="effectTransfer">Effect Transfer (4/3)</option>
                            <option value="empowerAttack">Empower Attack (6/3)</option>
                            <option value="energyAttacker">Energy Attacker (6/3)</option>
                            <option value="fastCompanion">Fast Companion (2/1)</option>
                            <option value="fastHealing">Fast Healing (4)</option>
                            <option value="favorableInsight">Favorable Insight (3)</option>
                            <option value="feint">Feint (6)</option>
                            <option value="fightingSpirit">Fighting Spirit (6/3)</option>
                            <option value="hardenedDefense">Hardened Defense (6/3)</option>
                            <option value="hardenedResistance">Hardened Resistance (6/3)</option>
                            <option value="hiddenCompanion">Hidden Companion (4/2)</option>
                            <option value="ignoreEffect">Ignore Effect (5)</option>
                            <option value="improvedDamageIncrement">Improved Damage Inc. (4/2)</option>
                            <option value="improvedSwimming">Improved Swimming (4)</option>
                            <option value="increasedSize">Increased Size (2/1)</option>
                            <option value="inspire">Inspire (5)</option>
                            <option value="interruptAttack">Interrupt Attack (3/2)</option>
                            <option value="intimidate">Intimidate (5/3)</option>
                            <option value="ironDefense">Iron Defense (4/2)</option>
                            <option value="Jump">Jump (4)</option>
                            <option value="mount">Mount (3/1)</option>
                            <option value="nimbleMovement">Nimble Movement (4)</option>
                            <option value="nullify">Nullify (5/3)</option>
                            <option value="overloadLimits">Overload Limits (6)</option>
                            <option value="passiveHealing">Passive Healing (4)</option> (6)
                            <option value="physicalAttacker">Physical Attacker (6/3)</option>
                            <option value="proficiency">Proficiency (2)</option>
                            <option value="protector">Protector (5)</option>
                            <option value="provoke">Provoke (4/2)</option>
                            <option value="quickToAct">Quick to Act (3)</option>
                            <option value="recharge">Recharge (5/3)</option>
                            <option value="recklessAttack">Reckless Attack (5/3)</option>
                            <option value="recovery">Recovery (3)</option>
                            <option value="resistant">Resistant (4/2)</option>
                            <option value="resoluteAura">Resolute Aura (5)</option>
                            <option value="resoluteStrike">Resolute Strike (5)</option>
                            <option value="revenge">Revenge (5)</option>
                            <option value="rollingRecovery">Rolling Recovery (4)</option>
                            <option value="senseMalice">Sense Malice (2)</option>
                            <option value="sizeUp">Size Up (3/1)</option>
                            <option value="spiritSight">Spirit Sight (5)</option>
                            <option value="sprinter">Sprinter (4/2)</option>
                            <option value="strengthOfWill">Strength of Will (5)</option>
                            <option value="teamTactics">Team Tactics (6)</option>
                            <option value="tireless">Tireless (5/2)</option>
                            <option value="tough">Tough (6/3)</option>
                            <option value="toss">Toss (5/2)</option>
                            <option value="underhanded">Underhanded (5)</option>
                            <option value="unmovable">Unmovable (4/2)</option>
                            <option value="versatileFighter">Versatile Fighter (6/3)</option>
                        </optgroup>
                        <optgroup label="Season 2 Skills">
                            <option value="abundantCreation">Abundant Creation (5)</option>
                            <option value="afterimage">Afterimage (4)</option>
                            <option value="allyMount">Ally Mount (3/1)</option>
                            <option value="areaShield">Area Shield (4)</option>
                            <option value="battleAnalysis">Battle Analysis (6)</option>
                            <option value="clash">Clash (3)</option>
                            <option value="clone">Clone (6/3)</option>
                            <option value="cloneTactics">Clone Tactics (5)</option>
                            <option value="combatToss">Combat Toss (4)</option>
                            <option value="companionZoneOfControl">Companion ZOC (4/4)</option>
                            <option value="damageFeedback">Damage Feedback (5)</option>
                            <option value="daredevil">Daredevil (4)</option>
                            <option value="divingEscape">Diving Escape (5/2)</option>
                            <option value="effectCapture">Effect Capture (4)</option>
                            <option value="extendedRevival">Extended Revival (4)</option>
                            <option value="favorableSuccess">Favorable Success (4)</option>
                            <option value="finalAttack">Final Attack (6)</option>
                            <option value="flankAttack">Flank Attack (4)</option>
                            <option value="healthTransference">Health Transference (4)</option>
                            <option value="lineDeflect">Line Deflect (5)</option>v
                            <option value="mobileCover">Mobile Cover (5)</option>
                            <option value="mobileDodge">Mobile Dodge (4)</option>
                            <option value="opportunisticDodge">Opportunistic Dodge (6)</option>
                            <option value="phasing">Phasing (5)</option>
                            <option value="portal">Portal (6/3)</option>
                            <option value="protectAlly">Protect Ally (2)</option>
                            <option value="protectMaster">Protect Master (3)</option>
                            <option value="pushAway">Push Away (4/2)</option>
                            <option value="rangedInterrupt">Ranged Interrupt (4)</option>
                            <option value="rangedRevival">Ranged Revival (3)</option>
                            <option value="refractionPoint">Refraction Point (4/2)</option>
                            <option value="risingAttack">Rising Attack (6)</option>
                            <option value="seal">Seal (6/3)</option>
                            <option value="shadowMeld">Shadow Meld (6)</option>
                            <option value="shrugOff">Shrug Off (6)</option>
                            <option value="splitMove">Split Move (6)</option>
                            <option value="staminaTransference">Stamina Transference (6)</option>
                            <option value="swiftStep">Swift Step (5/2)</option>
                            <option value="tossingCompanion">Tossing Companion (3/1)</option>
                            <option value="transposition">Transposition (4)</option>
                            <option value="trustingCompanion">Trusting Companion (4)</option>
                            <option value="wallWalk">Wall Walk (4)</option>
                            <option value="waterAdaptation">Water Adaptation (6)</option>
                            <option value="waterWalk">Water Walk (4)</option>
                            <option value="xRayVision">X-Ray Vision (4)</option>
                        </optgroup>
                        <optgroup label="Season 3 Skills">
                            <option value="attackNodeNetwork">Attack Node Network (4)</option>
                            <option value="companionSense">Companion Sense (2)</option>
                            <option value="defensiveClash">Defensive Clash (4)</option>
                            <option value="deflectingShield">Deflecting Shield (4)</option>
                            <option value="exploitWeakness">Exploit Weakness (6)</option>
                            <option value="flunkyDomination">Flunky Domination (5)</option>
                            <option value="fly">Fly (6/2)</option>
                            <option value="flyingCompanion">Flying Companion (3/3)</option>
                            <option value="instantMonut">Instant Mount (3)</option>
                            <option value="prepared">Prepared (6)</option>
                            <option value="reactiveCompanion">Reactive Companion (4)</option>
                            <option value="refractionChain">Refraction Chain (6)</option>
                            <option value="swiftJump">Swift Jump (3)</option>
                            <option value="unshakeable">Unshakeable (6)</option>
                            <option value="unstoppable">Unstoppable (6)</option>
                        </optgroup>
                        <optgroup label="Season 4 Skills">
                            <option value="breakValorLimit">Break Valor Limit (6)</option>
                            <option value="expandedReach">Expanded Reach (8)</option>
                            <option value="extendedRange">Extended Range (4)</option>
                            <option value="extraAction">Extra Action (12)</option>
                            <option value="freeFlight">Free Flight (3)</option>
                            <option value="freeSwiftStep">Free Swift Step (5)</option>
                            <option value="regeneration">Regeneration (6/4)</option>
                            <option value="staminaRecovery">Stamina Recovery (4/2)</option>
                            <option value="teleportation">Teleportation (6)</option>
                            <option value="unyieldingDetermination">Unyielding Determination (6)</option>
                            <option value="violentAura">Violent Aura (4)</option>
                        </optgroup>
                        <optgroup label="Season 1 (Optional Rules)">
                            <option value="elementalResistance">Elemental Resistance (4/2)</option>
                            <option value="elementalAttunement">Elemental Attunement (3)</option>
                            <option value="illusoryDisguise">Illusory Disguise (3)</option>
                            <option value="illusoryTerrain">Illusory Terrain (4/2)</option>
                            <option value="pierceIllusion">Pierce Illusion (4)</option>
                            <option value="principled">Principled (2)</option>
                            <option value="polearmWielder">Polearm Wielder (5)</option>
                            <option value="rangedWeaponWielder">Ranged Weapon Wielder (4/2)</option>
                        </optgroup>
                        <optgroup label="Season 2 (Optional Rules)">
                            <option value="illusoryAssailant">Illusory Assailant (6/3)</option>
                        </optgroup>
                        <optgroup label="Season 1 (NPC Only)">
                            <option value="invisibility">Invisibility (8)</option>
                        </optgroup>
                        <optgroup label="Season 2 (NPC Only)">
                            <option value="revive">Revive (8/3)</option>
                        </optgroup>
                        <optgroup label="Season 4 (NPC Only)">
                            <option value="limitlessPower">Valiant (12)</option>
                        </optgroup>
                        <optgroup label="Villains, Creatures and Foes (BETA)">
                        </optgroup>
                        <optgroup label="Traits">
                            <option value="aquatic">Aquatic (1)</option>
                            <option value="construct">Construct (8)</option>
                            <option value="elemental">Elemental (5)</option>
                            <option value="undead">Undead (8)</option>
                        </optgroup>
                        <optgroup label="Season 1">
                            <option value="diminuitive">Diminuitive (6)</option>
                            <option value="healer">Healer (4/2)</option>
                            <option value="increasedLength">Increased Length (1/1)</option>
                            <option value="morale">Morale (6)</option>
                            <option value="hardenedResolve">Hardened Resolve (6)</option>
                            <option value="amphibious">Amphibious (3)</option>
                            <option value="toweringPresence">Towering Presence (6)</option>
                            <option value="humanshape">Humanshape (3)</option>
                            <option value="limitedFlight">Limited Flight (4/2)</option>
                            <option value="pressingSwarm">Pressing Swarm (6)</option>
                            <option value="skillCopy">Skill Copy (?)</option>
                            <option value="swiftStance">Swift Stance (3/1)</option>
                            <option value="increasedCompanionSize">Increased Companion Size (1/1)</option>
                        </optgroup>
                        <optgroup label="Season 2">
                            <option value="largeHead">Large Head (1)</option>
                            <option value="limitedRegeneration">Limited Regeneration (4/3)</option>
                            <option value="longTail">Long Tail (1)</option>
                            <option value="trample">Trample (8)</option>
                            <option value="ultimateAttack">Ultimate Attack (12)</option>
                            <option value="victorAtAnyCost">Victor At Any Cost (8)</option>
                        </optgroup>
                        <optgroup label="Season 3">
                            <option value="alteredDurability">Altered Durability (3)</option>
                            <option value="burrow">Burrow (6)</option>
                            <option value="durableFlunky">Durable Flunky (6/3)</option>
                            <option value="resurrectingFlunky">Resurrecting Flunky (8)</option>
                            <option value="standTall">Stand Tall (6)</option>
                            <option value="terrainAdaptation">Terrain Adaptation (6)</option>
                        </optgroup>
                        <optgroup label="Season 4">
                            <option value="destructiveBurrow">Destructive Burrow (6)</option>
                            <option value="freeBurrow">Free Burrow (3)</option>
                            <option value="landAdaptation">Land Adaptation (4)</option>
                            <option value="shapeshifter">Shapeshifter (12)</option>
                            <option value="unscrupulous">Unscrupulous (6)</option>
                        </optgroup>
                    </select>
                    <span class="label">Level</span> <input class="skill-level" type="number" name="attr_skilllevel" value="1" />
                    <span name="attr_warning"></span>
                </div>
                <span class="label">Notes</span> <input class="notes" type="text" name="attr_skillnotes" />
            </div>
        </fieldset>

        <div class="unspent-sp"><span name="attr_unspentSkillPoints"></span> SP UNSPENT</div>
    </div>

    <div class="sheet-tab-content sheet-tab3">
        <div class="techs-header">TECHNIQUES</div>

        <fieldset class="repeating_techs">
            <div class="tech-name">
                <input type="text" class="tech-name" name="attr_tech_name" value="New Technique" />
            </div>
            <div class="tech">
                <div class="spacer"></div>
                <div class="tech-level">
                    <div class="tech-header">
                        <span class="label">Tech Level</span>
                        <span class="derived-value" name="attr_tech_level">
                    </div>
                </div>
                <div class="tech-button">
                    <input type="hidden" class="tech-name" name="attr_tech_stat_roll" value="[[1d10+0]] Muscle" />
                    <input type="hidden" class="tech-name" name="attr_tech_micro_summary" value="" />
                    <button class="valor-button" type='roll' 
                        value='&{template:valor} {{name=@{tech_name}}} {{roll=@{tech_stat_roll}}} {{summary=@{tech_micro_summary}}} {{skills=@{tech_granted_skills}}} {{flaws=@{tech_inflicted_flaws}}} {{mimic=@{tech_mimic_target}}}'> Use Technique</button>
                </div>
                <div>
                    <span class="label">Core:</span>
                </div>
                <div class="tech-core">
                    <select class="tech-field" name="attr_tech_core">
                        <option value="barrier">Barrier Core</option>
                        <option value="boost">Boost Core</option>
                        <option value="damage" selected="selected">Damage Core</option>
                        <option value="healing">Healing Core</option>
                        <option value="mimic">Mimic Core</option>
                        <option value="summoning">Summoning Core</option>
                        <option value="weaken">Weaken Core</option>
                        <optgroup label="Ultimate Cores">
                            <option value="domain">Domain</option>
                            <option value="ultDamage">Ultimate Attack</option>
                            <option value="ultMimic">Ultimate Mimic</option>
                            <option value="ultTransform">Transformation</option>
                        </optgroup>
                        <option value="custom">Custom Core</option>
                    </select>
                </div>
                <div class="tech-core-level">
                    <span class="label">Core Power:</span>
                    <input class="tech-field tech-small-input" type="number" name="attr_tech_core_level" value="1" />
                </div>
                <div class="tech-summary">
                    <div><span name="attr_tech_description"></span></div>
                    <div><span name="attr_tech_summary"></span></div>
                    <div><span name="attr_tech_warnings"></span></div>
                </div>
                <div>
                    <span class="label">Attribute:</span>
                </div>
                <div class="tech-attribute">
                    <select class="tech-field" name="attr_tech_stat">
                        <option value="none" selected="selected">None</option>
                        <option value="strength">Strength</option>
                        <option value="agility">Agility</option>
                        <option value="spirit">Spirit</option>
                        <option value="mind">Mind</option>
                        <option value="guts">Guts</option>
                    </select>
                </div>
                <div class="tech-cost">
                    <input type="checkbox" class="conditional-check" name="attr_tech_can_edit_cost">
                    <div class="conditional-block">
                        <span class="label">ST Cost:</span>
                        <input class="tech-field tech-small-input" type="number" name="attr_tech_custom_cost" value="0" />
                    </div>
                    <div class="conditional-block-inverse">
                        <span class="label">ST Cost</span>
                        <span class="derived-value" name="attr_tech_cost"></span>
                    </div>
                </div>
                <div class="tech-description">
                    <div class="label">Description</div>
                    <div>
                        <textarea class="smallertext tech-field" name="attr_tech_description"></textarea>
                    </div>
                </div>
                <div class="tech-optional-fields">
                    <div class="tech-conditional-field">
                        <input type="checkbox" class="conditional-check" name="attr_tech_has_skills">
                        <div class="tech-block conditional-block">
                            <span class="label">Skills:</span>
                            <input type="text" class="tech-field" name="attr_tech_granted_skills" />
                            (<span class="sp_label" name="attr_tech_skill_sp"></span>/<span class="sp_label" name="attr_tech_skill_sp_max"></span>)
                        </div>
                    </div>
                    <div class="tech-conditional-field">
                        <input type="checkbox" class="conditional-check" name="attr_tech_has_flaws">
                        <div class="tech-block conditional-block">
                            <span class="label">Flaws:</span>
                            <input type="text" class="tech-field" name="attr_tech_inflicted_flaws" />
                            (<span class="sp_label" name="attr_tech_flaw_sp"></span>/<span class="sp_label" name="attr_tech_flaw_sp_max"></span>)
                        </div>
                    </div>
                    <div class="tech-conditional-field">
                        <input type="checkbox" class="conditional-check" name="attr_tech_is_mimic">
                        <div class="tech-block conditional-block">
                            <span class="label">Mimicked Tech:</span>
                            <input class="tech-field" type="text" name="attr_tech_mimic_target" />
                        </div>
                    </div>
                </div>
                <div class="tech-modifiers">
                    <div class="label">Modifiers (one per line)</div>
                    <div>
                        <textarea class="smalltext tech-field" name="attr_tech_mods" rows="3" cols="40"></textarea>
                    </div>
                    <div>
                        Total Mod Levels <span name="attr_tech_mod_level" class="derived-value"></span>
                    </div>
                </div>
                <div class="tech-limits">
                    <div class="label">Limits (one per line)</div>
                    <div>
                        <textarea class="smalltext tech-field" name="attr_tech_limits" rows="3" cols="40"></textarea>
                    </div>
                    <div>
                        Total Cost Reduction <span name="attr_tech_limit_st" class="derived-value"></span>
                    </div>
                </div>
            </div>
        </fieldset>
        <div class="unspent-tp"><span name="attr_unspentTechPoints"></span> TP UNSPENT</div>
    </div>

</div>

<rolltemplate class="sheet-rolltemplate-valor">
    <div class="outer">
        <div class="header">
            {{name}} {{#mimic}}[{{mimic}}]{{/mimic}}
        </div>
        <div>
            {{roll}}
        </div>
        <div>
            {{summary}}
        </div>
        {{#skills}}
        <div>
            Skills: {{skills}}
        </div>
        {{/skills}}
        {{#flaws}}
        <div>
            Flaws: {{flaws}}
        </div>
        {{/flaws}}
    </div>
</rolltemplate>